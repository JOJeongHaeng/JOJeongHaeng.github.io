---
layout: single
title:  "2023 C++ 학습하기 1차시"
categories: coding
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


# C++







---





## 01장 C++ 첫걸음



01장에서는 C++의 탄생 배경을 살펴보고 C++ 프로그램을 작성할 때 지켜야할 몇가지 규칙을 알아보자.





### 01.1 C++를 배우자



C++는

>C의 절자적 언어



>C에 클래스를 추가하여 실현하는 C++의 객체 지향 언어 방식



>C++의 템플릿이 지원하는 일반화 프로그래밍 방식



이 세 가지 프로그래밍 방식을 하나로 결합한다.



C++를 사용하는 주된 이유는 객체 지향 프로그래밍을 할 수 있기 때문이므로 C의 기초사항을 잘 알아야 한다. 그 이유는 기본적인 데이터형과 연산자, 제어 구조, 구문 규칙을 C 언어가 제공하기 때문이다.





### 01.2 C++의 탄생



>점점 기능이 강력해진 컴퓨터는 더 크고 더 복잡한 프로그램을 요구



>1970년대에 C나 Pascal과 같은 컴퓨터 언어들이 등장며 이 문제의 해결책을 제시해 구조적 프로그래밍의 시대를 열음



>C 언어는 구조적 프로그래밍을 위한 도구를 제공하며, 통신 포트나 디스크 드라이브와 같은 하드웨어까지 직접 제어할 수 있었고, 크기가 작으면서도 실행 속도가 빠른 프로그램을 작성할수 있었기에 1980년대에 가장 인기 있는 프로그래밍이 됨.





* C언어



  1970년대 초반에 벨 연구소에서는 Unix라는 운영체제를 개발하고 있었는데 이 과정에서 저수준의 언어의 효율성과 하드웨어 접근 능력, 고수준 언어의 일반성과 이식성이 결합된 프로그래밍 언어가 필요했고 이 때 C가 만들어졌다.





* C의 프로그래밍 철학



  일반적으로 컴퓨터 언어는 '데이터'와 '알고리즘' 두 개념을 다룬다.

  >'데이터'는 프로그램이 사용하고 처리하는 정보



  >'알고리즘'은 프로그램이 데이터를 처리하는 방법



  C는 데이터보다 알고리즘에 더 치중한 절차적언어이다. 컴퓨터가 수행해야 할 동작들을 명확히 구분하고, 그 구분된 동작들을 프로그래밍 언어로 구현하는 것이다.



  ex) for 루프, while 루프, do while 루프 if else 구문 등 정형화 된 조건을 통해 분기를 사용하도록 제한.



  하향식 설계 또한 구조적 프로그래밍의 하나의 철학이다.





* C++의 등장: 객체 지향 프로그래밍



  구조적 프로그래밍 철학이 프로그램의 간결성과 신뢰성, 유지 보수의 용이설에 많은 향상을 가져왔지만 규모가 큰 프로그래밍에는 여전히 어려웠다.



  이 해결책으로 객체 지향 프로그래밍 철학이 등장하였다.

  해결해야 할 문제를 절차적 접근 방식에 억지로 끼워 맞추지 않고 언어 자체를 해결해야 할 문제에 맞춘다. 즉, 해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계를 한다.

  C++에서는 클래스가 그와 같은 목적으로 설계되는 새로은 데이터형이고, 객체는 그러한 클래스에 의해 만들어지는 특정한 데이터 구조이다.





* C++와 일반화 프로그래밍



  일반화 프로그래밍과 OOP는 소스코드의 손쉬운 재활용이라는 목표와, 포괄 개념의 추상화 기술을 서로 공유한다.



  > OPP는 데이터 측면을 강조

  

  > 일반화 프로그래밍은 알고리즘 측면을 강조





* C++의 기원



  C++은 C와 마찬가지로 벨 연구소에서 개발되었다.

  C++ 개발의 주 목적은 "프로그래머들이 보다 쉽고 즐겁게 유용한 프로그래밍을 작성 할 수 있도록 하는 것" 이었다.


### 01.3 이식성과 표준



프로그램이 이식성을 갖기 위해서는 아래의 두 가지 장애 요인이 있다.



1. 하드웨어

  특정 하드웨어에 종속적인 프로그램은 이식성을 갖지 못한다.

3. 프로그래밍 언어 간의 상이성

  여러 버전의 C++중에 C++98을 표준으로 정했다.







### 01.4 프로그램 작성 요령



1. 손에 익은 텍스트 에디터를 사용하여 프로그램을 작성하고 파일로 저장. (이 파일이 프로그램의 소스 코드)



2. 소스 코드를 컴파일한다. (번역 된 파일이 목적 코드)



3. 목적코드에 부가적인 코드를 링크시킨다.



* 소스 코드 파일 작성



  소스코드의 파일 이름을 생성할 때에는 그 언어의 소스 코드라는 것을 나타내기 위해 반드시 접미어를 붙여야 한다. 이를 확장자라고 한다.



  확장자는 어떤 컴파일러를 사용하느냐에 따라 달라진다.


## 02장 C++시작하기


### 02.1 C++의 시작



> '//' 는 주석이다.



> 대문자와 소문자를 구별한다.



> 이 책에서는 확장자로 cpp를 사용한다.



```cpp
#include <iostream>
int main()
{
    using namespace std;
    cout << "C++의 세계로 오십시오.";
    cout << endl;
    cout << "후회하지 않으실 겁니다!" << endl;
    return 0;
}
```

위 코드는 다음과 같은 구성 요소들을 가진다.

> //로 시작되는 주석문

> #include 전처리 지시자

> 함수 머리: int main()

> using namespace 지시자

> '{'와 '}'로 범위가 정해지는 함수 몸체

> C++의 cout 기능을 사용하여 메세지를 출력하는 구문들

> main() 함수를 종료하는 return 구문

* main()함수

  
  기본구조는 다음과 같다.
  
```cpp
int main()
{
    구문들
    return 0;
}
```

>int main() 함수가 자신을 호출한 함수로부터 어떠한 정보도 전달받지 않지만('()'안이 비어있음), 그 함수에게 정수값을 리턴한다는것(int).


* C++ 주석문

  주석문은 프로그래머가 프로그램 안에 기록해 두는 일종의 메모로, 프로그램의 구역을 구분하거나 코드의 어떤부분이 무슨 역할을 하는 것인지 표시하는 데 사용한다.

* C++ 전처리기와 iostream 파일

  C++의 일반적인 입출력 기능을 사용하려면 다음 두행을 프로그램에 꼭 넣어야 한다.

```cpp
#include <iostream>  // 전처리 지시자

using namespace std;
```

이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다. 이와 같이 컴파일되기 전에 소스코드에 텍스트를 추가하거나 텍스트를 대체하는 것이 전처리기가 수행하는 기본적인 역할이다.

iostream의 i는 프로그램안으로 들어오는 정보(입력), o는 프로그램이 바깥으로 내보내는 정보(출력)를 나타낸다. cout 기능을 사용하려면 이러한 정의가 필요하다.

* 헤더 파일 이름

iostream과 같은 파일을 포함파일 또는 헤더 파일이라고 부른다.

C++에서는 이름 짓는 규칙이 바뀌었는데 C의 헤더 파일의 이름에서 '.h'를 뺀 것이다.

|헤더 파일의 종류|규칙|보기|설명|
|---|---|---|---|
|C++ 구식 스타일| .h로 끝남| iostream.h| C++ 프로그램에서 사용할 수 있다.|
|C 구식 스타일| .h로 끝남| math.h| C와 C++ 프로그램에 모두 사용할 수 있다.|
|C++ 최신 스타일| 확장자 없음| iostream| C++ 프로그램에서 사용할 수 있고, namespace std를 사용한다.|
|C 변환 스타일| C 접두어, 확장자 없음| cmath| C++ 프로그램에서 사용할 수 있고, namespace std와 같이 C에 없는 기능은 사용할 수도 있고 못할 수도 있다.|

* 이름 공간

  iostream.h 대신에 iostream을 사용할 때 프로그램이 iostraem의 정의를 사용할 수 있게 하려면 'using namespace std;' 이름 공간 지시자를 사용해야한다.
이것을 using 지시자라고 한다.

* cout을 이용한 C++의 출력

```cpp
cout << "C++의 세계로 오십시오.";
```
> 큰따옴표 안에 들어 있는 부분이 출력할 메세지이다. C++에서 이 연속된 문자들을 문자열이라고 부른다.

> << 표시는 구문이 그 문자열을 cout에 전달한다는 것을 뜻한다.

> cout은 문자열, 수, 문자 들을 포함한 여러가지 다양한 정보들을 출력하는 방법을 알고 있는, 미리 정의된 객체이다.

* 조정자 endl

```cpp
cout << endl;
```

  endl은 새로운 행이 시작된다는 중요한 개념을 나타내는 특별한 C++표기이다.
  
  cout은 문자열을 출력하고 다음 행의 시작 위치로 커서를 자동으로 넘겨주지 않기에 endl을 통해 줄바꿈을 해주어야 한다.

* 개행 문자(\n)

```cpp
cout << "다음은 뭔데?\n";    // \n은 새로운 행을 시작하라는 의미
```

  기본적으로 cout << endl;와 cout << "\n"은 같은 기능을 한다.

* C++ 소스 코드의 모양

  C++은 세미콜론으로 구문의 끝을 표시하므로 하나의 구문을 여러 행에 펼칠 수도 있고 여러개의 구문을 한 행에 놓을 수도 있다.

  하지만 이름과 문자열 중간에는 빈칸이나 캐리지 리턴을 넣을 수는 없다.

* 토큰과 화이트 스페이스

  한 행의 코드에서 더 이상 분리할 수 없는 기본 요소를 토큰이라 한다.

  일반적으로 하나의 토큰은 빈칸, 탭, 캐리지 리턴에 의하여 다음 토큰과 분리되는데 이들을 집합적으로 화이트 스페이스라고 한다.

* C++ 소스 코드 스타일

> 한행에 하나의 구문을 사용한다.
>
> 함수를 여는 중괄호'{'와 닫는 중괄호 '}'에 각각 한행을 할애한다.
>
> 함수 안에 들어갈 구문들은 중괄호에서 약간 오른쪽으로 들어간 위치에서 시작한다.
>
> 함수 이름과 괄호 사이에는 어떠한 화이트스페이스도 넣지 않는다.

### 02.2 C++구문

```cpp
// carrots.cpp
// 하나의 변수를 사용하고 출력한다.

#include <iostream>

int main()
{
  using namespace std;

  int carrots;    // 정수 변수를 선언

  carrots = 25;    //변수에 값을 대입
  cout << "나는 당근을 ";
  cout << carrots;
  cout << "개 가지고 있다.";
  cout << endl;
  carrots = carrots-1;
  cout << "아삭아삭, 이제 당근은 " << carrots << "개이다." << endl;
  return 0;
}
```

실행 결과는
```
나는 당근을 25개 가지고 있다.
아삭아삭, 이제 당근은 24개이다.
```

변수를 선언 하는 선언 구문, 변수에 값을 대입하는 대입 구문이 추가 되었다.

* 선언 구문과 변수

```cpp
int carrots;
```

  하나의 정수를 저장할 수 있는 기억 공간을 프로그램이 사용할 예정이라고 선언한다.
  
  그러면 컴파일러는 이를 위한 기억공간을 대입하고 그 위치가 어디인지 말해 주는 꼬리표를 붙이는 작업을 수행한다.

  다음으로 해야할 일은 저장된 데이터의 이름을 선언하는 것이다. 기억 공간에 저장되어 있는 값을 carrots이라는 이름으로 사용하겠다는 것이다.
  
  carrots와 같은 역할을 하는 것을 변수라고 부른다.

* 대입 구문

  대입 구문은 기억 위치에 어떤 값을 대입한다.

```cpp
carrots = 25;    // 변수 carrots로 나타내는 기억 위치에 정수 25를 대입
```

여기서 등호는 대입 연산자라고 부른다. 대입 연산자를 연이어 사용할 수도 있다.

```cpp
int steinway;
int baldwin;
int yamaha;
yamaha = baldwin = steinway = 88;
```

위 대입 구문은 오른쪽에서 왼쪽으로 차례대로 처리된다.

* cout의 새로운 사용법

  지금까지 cout에 출력한 문자열을 넘겨주었지만 정수값을 가지고 있는 변수를 cout에 넘겨줄 수도 있다.

```cpp
cout << carrots;
```

carrots 이라는 단어를 출력하지 않고 변수 carrots에 저장되어 있는 정수값인 25를 출력한다.

cout은 내부적으로 carrots를 정수 25로 대체하고 적당한 출략 믄지 '2'와 '5'로 변환하는 작업을 한다. (cout이 int형의 수를 출력하기 전에 문자형으로 변환한다.)

### 02.3 C++의 기타 구문

cout은 출력을 수행하는 객체인데 반하여 cin은 입력을 수행하는 객체이다.

```cpp
//getinfo.cpp -- 입력과 출력
#include <iostream>

int main()
{
  using namespace std;

  int carrots;

  cout << "당근을 몇개나 가지고 있니?" << endl;
  cin >> carrots;    // C++ 입력
  cout << "여기 두 개가 더 있다. ";
  carrots = carrots + 2;
// 다음 라인은 출력을 연결한다.
  cout << "이제 당근은 모두 " << carrots << "개이다." << endl;
  return 0;
}
```

실행 결과는 다음과 같다.

```
당근을 몇 개나 가지고 있니?
12
여기 두 개가 더 있다. 이제 당근은 모두 14개이다.
```

cin을 사용하여 키보드로부터 정수를 입력받았다.

*cin 사용법

```cpp
cin >> carrots
```

  cin은 '>>' 연산자를 사용하여 입력 스트림에서 문자들을 가져온다. 가져온 정보를 저장할 변수는 '>>' 연산자의 오른쪽에 적는다.

* count에 의한 출력의 결합

  iostream 파일에는 << 연산자가 다음과 같이 여러 개의 출력을 하나로 결합 할 수 있도록 정의되어 있다.

```cpp
cout << "이제 당근은 모두 " << carrots << "개이다." << endl;
```

* cin과 cout: 클래스 맛보기

  클래스는 사용자가 정의하는 데이터형이다. 클래스를 정의하려면, 클래스로 표현할 수 있는 정보의 종류는 무엇이고 그것으로 수행할 수 있는 동작이 무엇인지 서술해야한다.

### 02.4 함수

C++ 함수는 리턴값이 있는 함수, 리턴값이 없는 함수 두 가지 유형이 있다.

* 리턴값이 있는 함수

```cpp
x = sqrt(6.25);    // 값 2.5를 리턴하여 x에 대입
```

  sqrt(6.25) 라는 표현이 sqrt() 함수를 호출한다.

  C++은 함수 원형 구문을 사용하여 리턴 값의 정보를 컴파일러에게 전달해야한다.

  C++ 라이브러리에는 sqrt() 함수가 소수부가 있는 수를 매개변수로 전달받으며, 동일한 데이터형을 리턴한다고 정의 되어있다.

```cpp
double sqrt(double);    // 함수 원형
```

프로그램에서 sqrt() 함수를 사용하려면 함수 원형을 제공해야 하는데 이 방법에는 두가지가 있다.

> 함수 원형을 소스 코드 파일에 직접 입력한다.

> 함수 원형이 들어 있는 cmath(구식 시스템에서는 math.h) 헤더 파일을 포함시킨다.

함수 원형과 함수 정의는 다르다. 함수 원형은 함수에 전달하는 정보와 리턴하는 정보만 서술하는 반면 함수 정의는 수행할 작업을 위한 실제 코드를 포함한다.

함수 원형은 일반적으로 main() 함수 정의 앞에 둔다.

```cpp
#include <iostream>
#include <cmath>    // cmath 해더 파일을 포함시켜 함수 원형을 제공

int main()
{

  ...

}
```

* 변이 함수들

  어떤 함수는 하나 이상의 정보를 요구하는데 여러 개의 매개변수를 콤마로 분리한다.

```cpp
double pow(double, double);    // 2개의 매개변수를 가진 함수 원형
```

```cpp
answer = pow(5.0, 8.0);    // 5의 8제곱
```

  매개변수를 사용하지 않는 함수도 있다.

```cpp
int rand(void);    // C라이브러리의 함수. 임의의 정수 리턴
```

  값을 리턴하지 않는 함수도 있다.

```cpp
coid bucks(double);    // bucks ()는 값을 리턴하지 않으므로 대입 구문이나 다른 표현의 일부로 사용할 수 없고, 순수한 함수 호출 구문으로만 사용
```

* 사용자 정의 함수

  사용자가 직접 함수를 작성하는 것이 사용자 정의 함수이다. main() 함수도 사용자 정의함수이다.

```cpp
// ourfunc.cpp -- 사용자가 작성하는 함수를 정의한다.
#include <iostream>
void simon(int);    // simon()을 위한 함수 원형

int main()
{
  using namespace std;
  simon(3);    // simon() 함수를 호출
  cout << "정수를 하나 고르시오: ";
  int count
  cin >> count;
  simon(count);    // simin() 함수를 다시 호출
  cout << "끝!" << endl;
  return 0;
}

void simon(int n)    // simon() 함수를 정의
{
  using namespace std;
  cout << "simon 왈, 발가락을 " << n << "번 두두려라." << endl;
}    // void형 함수는 리턴값이 없기에 return 구문이 필요없다.
```

  main() 함수는 simon() 함수를 두 번 호출한다.


* 함수 모양

```cpp
type functionname(arugumentlsit)
{
  statements
}
```


* 함수 머리  

  simon() 함수는 다음과 같은 함수 머리를 가지고 있다.

```cpp
void simon(int n)    // void는 값을 리턴 하지 않는다는 것. int n은 하나의 int형 매개변수를 전달 받는다는 것.
```

  main() 함수의 머리

```cpp
int main()    // int는 int형 값을 리턴한다는 것. 괄호가 비어 있는 것은 매개변수가 없다는 것.
```


* 리턴값이 있는 사용자 정의 함수

  영국을 방문하는 사람의 체중 환산 프로그램

```cpp
// convert.cpp -- 스톤을 파운드로 환산한다
#include <iostream>
int stonetolb(int);    // 함수 원형
int main()
{
  using namespace std;
  int stone;
  cout << "체중을 스톤 단위로 입력하시오: ";
  cin >> stone;
  int pounds = stonetolb(stone);
  cout << stone << " 스톤은 ";
  cout << pounds << " 파운드입니다." << endl;
  return 0;
}

int stonetolb(int sts)
{
  return 14 * sts;
}
```

```
체중을 스톤 단위로 입력하시오: 15
15스톤은 210 파운드입니다.
```

  cin으로 변수 stone에 int형 값을 입력받고 stonetolb() 함수의 매개변수로 전달되어 변수 sts에 대입된다. 이때 stonetolb() 함수는 14 * sts 수식값을 계산하여 main() 함수로 리턴한다. 

* 복수 함수 프로그램에 using 지시자 넣기

  두 개의 함수가 각각의 using 지시자를 가지고 있는 경우가 있다.

  이는 두 함수가 모두 cout을 사용하고, std 이름 공간에 있는 cout 정의에 접근할 필요가 있기 때문이다.

  두 함수가 std 이름 공간을 사용할 수 있게 만드는 또 다른 방법은 두 함수의 외부 그리고 위에 using 지시자를 넣는 것이다.

  (ex. int main()함수와 void simon(int n)함수를 정의하기 전 그 위에 using namespace std; 를 넣는다.) 

  하지만 접근이 필요한 함수들만 차별적으로 std 이름 공간에 접근 할 수 있도록 제한하는 것이 유리하다.


## 03장 데이터 처리

C++에 내장된 데이터형에는 기본형과 복합형이 있다.  

기본형에는 정수를 표현할 수 있는 정수형과, 소수부가 있는 수를 표현할 수 있는 부동 소수점형이 있다.

이 두가지 데이터형으로 모든 프로그래밍 상황에 대처할 수 없기 때문에 필요에 따라 변형 데이터형이 만들어져 있다.

### 03.1 간단한 변수

컴퓨터에 정보를 저장하려면 프로그램은 다음과 같은 세가지를 알아야 한다.

> 어디에 저장되는가?

> 어떤 값이 저장되는가?

> 어떤 종류의 정보인가?

* 변수 이름

  C++에서 변수 이름을 지을 때는 다음과 같은 간단한 규칙을 따른다.

> 변수 이름에는 영문자, 숫자, 밑줄(_) 문자만 사용할 수 있다.

> 숫자를 변수 이름의 첫 문자로 사용할 수 없다.

> 변수 이름에서 대문자와 소문자는 구별된다.

> C++의 키워드는 변수 이름으로 사용할 수 없다.

> 두 개의 밑줄 문자로 시작하는 이름이나, 밑줄 문자와 대문자로 시작하는 이름은, 그것을 사용하는 컴파일러와 리소스가 사용하기로 예약되어 있다. 하나의 밑줄 문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가 전역 식별자로 사용하기로 예약되어 있다.

> 변수 이름의 길이는 제한이 없으며, 변수 이름에 쓰인 모든 문자들이 유효하다. 그러나 어떤 플랫폼은 고유의 길이 제한이 있다.


* 정수형

  정수는 소수부가 없는 수를 말한다.

  무한하게 많은 정수를 모두 표현할 수 없기에 컴퓨터 언어는 정수들의 부분집합만을 나타낸다.

  C++의 정수형들은 서로 다른 크기의 메모리를 사용하여 정수를 저장하는데,

  signed 데이터형은 양수값과 음수값을 모두 나타낼 수 있으나, unsigned 데이터형은 양수값만 나타낼 수 있다.

  기본 정수형의 크기 순서로 나열하면 char, short, int, long 그리고 C++11의 long long 순이다. 각각 signed형과 unsigned형이 따로 존재한다.

* short, int, long, long long 정수형

  각각 정수를 저장하는 데 사용하는 비트 수가 다르다.

  > short형은 최소한 16비트 폭을 가진다.
  
  > int형은 최소한 short만큼은 크다.

  > long형은 최소한 32비트 폭을 가지며 최소한 int만큼은 크다.
  
  > long long형은 최소한 64비트 폭을 가지며 최소한 long만큼은 크다.
  
  다른 데이터 형들의 변수도 int형 변수처럼 선언할 수 있다.

```cpp
short score;    // short형의 정수형 변수를 만든다
int temperature;    // int형의 정수형 변수를 만든다
long position;    // long형의 정수형 변수를 만든다
```

  여기서 short와 long은 각각 short int, long int를 줄인 것이다.

  C++ 시스템의 정수 크기 얼마인지 알고 싶으면, 데이터형의 크기를 알아내는 C++의 도구를 사용할 수 있다.

  > 첫 번째 방법: sizeof 연산자를 이용한다.

  > 두 번째 방법: 여러 가지 정수형들의 범위에 대한 정보가 들어 있는 climits 헤더 파일을 열어 본다.

  이 파일에는 여러 정수형들의 서로 다른 한계값을 기호 이름으로 정의하고 있다. 예들 들어, int형의 최대값을 INT_MAX로 char형의 비트 수를 CHAR_BIT로 정의하고 있다.

* 초기화

  초기화는 선언과 대입을 하나로 조합한다.

```cpp
int n_int = INT_MAX;
```

위와 같은 구문은 n_int를 int형 변수로 선언하고 그 변수에 int형의 최대값을 대입한다. 또는 255와 같은 상수를 사용할 수 있다.

프로그램 실행이 그 선언에 접근할 때 수식 안의 값들이 모두 알려진다면 아래와 같이 수식으로도 초기화할 수 있다.

```cpp
int uncles = 5;    // uncles를 5로 초기화
int aunts = uncles;    // aunts를 5로 초기화
int chairs = aunts + uncles + 4;    // chairs를 14로 초기화
```

맨 앞의 uncles에 대한 선언이 맨 뒤로 옮겨지면 aunts와  chairs를 초기화하려고 시도할 때 uncles의 값을 아직 알 수 없기에 초기화에 실패한다.

* C++11에서의 초기화

  단일 변수 값을 초기화하는 데 중괄호({})를 사용한다.

```cpp
int emus{ 7 };    // emus를 7로 초기화
int rheas = { 12 };    //rheas를 12로 초기화
```

중괄호 안이 공백이라며 0으로 초기화 된다.


* unsigned형

  unsigned형을 이용하면 그 변수에 저장할 수 있는 최대값을 늘릴 수 있다.

  unsigned형은 결코 음수가 될 수 없는 양을 나타낼 때에만 사용된다.

  기본 정수형들의 unsigned형 변수를 만들려면 unsigned 키워드를 앞에 붙여서 선언하면 된다.

```cpp
unsigned short change;    // unsigned short형
unsigned int rovert;    // unsigned int형
unsigned quarterback;    // unsigned int형
```

unsigned만 있는 것은 unsigned int를 줄여서 나타낸 것이다.

* 어느 정수형을 사용할 것인가?

  일반적으로 int형이 가장 "자연스러운" 정수 크기로 설정된다.

  자연스러운 크기라는 것은 컴퓨터가 가장 효율적으로 처리하는 정수 형식을 말한다.  


  결코 음수가 될 수 없는 수를 나타낼 때는 unsigned 정수형을 사용한다.(보다 큰 값을 나타낼 수 있기 때문)


  16비트로 나타낼 수 있는 정수보다 더 큰 정수를 나타내야 할 때에는 long형을 사용해야한다.

* 정수형 상수

  정수형 상수란 프로그램에 직접 써 넣는 정수를 말한다.

  C++에서는 정수형 상수의 처음 숫자가 1~9이면 10진수이고, 첫 숫자가 0이고 두 번째 숫자가 1~7이면 8진수를 다타낸다.

  그리고 처음 두 문자가 0x 또는 0X이면 16진수를 나타낸다.

```cpp
// hexoct1.cpp --16진 정수형 상수와 8진 정수형 상수를 보여 준다
#include <iostream>
int main()
{
  using namespace std;
  int chest = 42;
  int waist = 0x42;
  int inseam = 042;
  ...
  return 0;
}
```

각각 10진, 16진, 8진 정수형으로 표현되어 있다.

cout은 기본적으로 정수를 10진수로 출력한다. 따라서 필요에 따라 cout << dec, cout << hex, cout << oct 등의 조정자를 통해 진법을 바꿔 출력해야한다.

* C++가 상수의 데이터형을 결정하는 방법

  C++은 정수형 상수를 모두 int형으로 저장한다. 그러나 특정 데이터형을 의미하는 접미어를 상수에 붙였을 때나 값이 너무 커서 int형으로 저장할 수 없을 때에는 그렇지 않다.

  접미어는 상수의 끝에 붙는 문자로 그 상수의 데이터형을 나타낸다.

  l이나 L은 long형, u나 U는 unsigned int형, uL은 unsigned long형을 의미한다.

  ex) 22022는 16비트 int형, 22022L은 32비트 long형으로 저장된다.

* char형: 문자와 작은 정수

  char형은 문자와 숫자를 저장하기 위한 것이다.

  대부분의 컴퓨터 시스템들은 256개보다 적은 개수의 문자들을 지원한다.

```cpp
// chartype.cpp --char형
#include <iostream>
int main()
{
  using namespace std;
  char ch;

  cout << "원하는 문자 하나를 입력하시오: " << endl;
  cin >> ch;
  cout << "감사합니다. ";
  cout << "당신이 입력한 문자는 " << ch << " 입니다." << endl;
  return 0;
}
```

```
원하는 문자 하나를 입력하시오:
M
감사합니다. 당신이 입력한 문자는 M 입니다.
```

입력할 때 cin은 키보드로부터 입력된 M을 값 77로 변환하고 출력할 때 cout은 값 77을 문자 M으로 변환한다.

* 멤버 함수: cout.put()

  멤버 함수는 클래스에 속하고, 클래스의 데이터를 다루는 방법을 정의한다.

  cout.put()은 객체 이름(cout)과 함수 이름(put())을 마침표(.)로 서로 연결해 맴버 함수를 사용할 수 있다.

  cout을 통해 클래스 멤버 함수인 put을 사용하겠다는 뜻이다.

* char형 상수

  일반적인 문자들을 나타내는 가장 간단한 방법은 작은 따옴표로 그 문자를 둘러싸는 것이다.

  > 'A'는 65이다. 문자 A에 해당하는 ASCII코드

  > 'a'는 97이다. 문자 a에 해당하는 ASCII코드


  키보드를 통해 프로그램 안으로 직접 입력할 수 없는 문자들이 있다.

  > \a는 스피커나 벨을 울리는 경보

  > \n은 개행

  > \"는 문자열을 분리하는 큰따옴표가 아닌 인용문에 사용하는 일반 문자(\를 이용해 오류없이 출력 가능해짐)

  > \b는 백스페이스 문자를 사용하여 커서를 뒤로 이동 시킨다.


* 유니버설 네임 코드

  C++는 특정 키보드와 무관한 국제 문자들을 표현하는 메커니즘을 가지고 있는데 이것을 유니버설 네임 코드의 사용이다.


* signed char형과 unsigned char형

  int형과 달리 char형은 signed형이나 unsingned형으로 정해져 있지 않다.

  특별한 한 가지 행동만 보여야 한다면 형을 지정해줘 명시적으로 제한할 수 있다.

  char형으로 수를 나타내고자 할 때 특히 중요하지만, 표준 ASCII 문자를 char형 변수에 저장할 때는 상관 없으므로 char라 쓰면 된다.


* 확장 char형: wchar_t

  프로그램이 1바이트로 표현할 수 없는 문자를 처리해야 하는 경우 두 가지 방법이 있다.

  > 첫째, 확장 문자 세트가 시스템의 기본 문자 세트면 컴파일러 개발업체가 char형을 처음부터 2바이트 혹은 그 이상으로 만드는 것
  
  > 둘째, 기본 문자 세트와 확장 문자 세트를 동시에 지원하는 것 (기본은 char형 즉 1바이트, 확장 문자 세트를 나타낼 때는 wchar_t형 즉 2바이트)
  

* bool형

  bool형 변수는 참 혹은 거짓의 값만을 가질 수 있다.

```cpp
bool isready = true;
```

true와 false는 int형인 1과 0으로 변환 될 수 있다.

```cpp
int ans = true;    // ans에 1이 대입
int promise = false;    // promise에 0이 대입
```

0이 아닌 값들은 true로, 0 값은 false로 변환된다.


### 03.2 const 제한자

const 키워드를 사용하여 변수를 선언하고 초기화 하자.

```cpp
const int MONTHS = 12;    // MONTHS는 12를 나타내는 기호 상수
```

이 프로그램 안에서 12 대신 MONTHS를 사요할 수 있게 되었다. 컴파일러는 이후에 MONTHS의 값을 변경하려는 어떠한 시도도 허용되지 않는다.

키워드 const는 선언의 의미를 제안하므로 제한자라고 불린다.

const 상수는 선언할 때 초기화하는 것이 좋다.


### 03.3 부동 소수점수

너무 커서 long형으로 나타낼 수 없는 경우 부동 소수점형으로 나타낼 수 있다.

컴퓨터는 소수부가 있는 값을 두 부분으로 나누어 저장하는데 한 부분은 기본값을 나타내고, 다른 한 부분은 기본값을 키우거나 줄이는 스케일을 나타낸다.

* 부동 소수점수의 표기

  C++이 부동 소수점수를 표기하는 방법은 두 가지이다.

  1. 소수점 표기법 그대로 따르기
 
  2. 지수 표기를 사용하는 것. 3.45E6은 값 3.45에 1,000,000를 곱하라는 뜻이다.

  2번에서 봤듯이 부동 소수점의 지수 표기는 매우 큰 수나 매우 작은 수를 나타내는 데 무척 유용하다.

  지수 표기는 소수점이 사용되지 않더라도 항상 그 수를 부동 소수점형으로 저장한다.

  E 또는 e를 사용할 수 있고, 지수는 + 또는 -부호를 가질 수 있다. 그러나 수에 빈칸이 들어 있으면 안된다.


* 부동 소수점형

  C++에는 float, double, long double의 세 가지 부동 소수점형이 있다.

  > float형은 최소한 32비트
  
  > double형은 float형보다 작지 않으면서 최소한 48비트
  
  > long double형은 최소한 double형과 같은 크기


* 부동 소수점형 상수

  부동 소수점형 상수는 기본적으로 double형으로 저장된다.

  float형으로 저장하고 싶으면 f나 F를 접미어로, long double형으로 저장하고 싶으면 l이나 L을 접미어로 사용해라

```cpp
1.234f        // float형 상수
2.45E20F      // float형 상수
2.345324E28   // double형 상수
2.2L          // long double형 상수
```

* 부동 소수점수의 장단점

  두 가지 장점

  1. 정수와 정수 사이에 있는 값을 나타낼 수 있다.
 
  2. 스케일을 사용하여 매우 큰 범위의 값을 나타낼 수 있다.
 
  단점

  1. 연산할 때 수치 연산 보조 프로세서가 없는 컴퓨터에서 정수 연산보다 속도가 느리다.
 
  2. 정밀도를 잃을 수 있다.

 정밀도 손실 문제를 봐보자

 ```cpp
// fltadd.cpp -- float형에서의 정밀도 손실 문제
#include <iostream>
int main()
{
  using namespace std;
  float a = 2.34E+22f;
  float b = a + 1.0f;

  cout << "a = " << a << endl;
  cout << "b - a = " << b - a << endl;
  return 0;
}
```

```
a = 2.34e+022
b - a = 0
```

1을 더했지만 float형은 처음 6개의 숫자 혹은 7개의 숫자까지만 나타낼 수 있으므로, 23번째 숫자에 1을 더한 것은 아무 효과를 갖지 못했다.


### 03.4 C++ 산술 연산자

C++은 기본적인 계산 -덧셈, 뺄셈, 곱셈, 나눗셈, 나머지셈-을 위해 다섯 가지 연산자를 제공한다.

각각 연산자는 연산의 대상으로 삼을 두 개의 값을 필요로 하는데 이를 피연산자라고 한다.

다음은 C++의 기본적인 산술 연산자 다섯 가지를 요약한 것이다.

> +연산자는 두 개의 피연산자를 더한다.

> -연산자는 첫 번째 피연산자에서 두 번째 피연산자를 뺀다.

> *연산자는 두 개의 피연산자를 곱한다.

> /연산자는 첫 번째 피연산자를 두 번째 피연산자로 나눈다. 두 개의 피연산자가 정수면 결과값은 목의 정수부이다.

> %연산자는 첫 번째 연산자를 두 번째 피연산자로 나누어 나머지를 구한다. 여기서 피연산자는 모두 정수여야 한다. 부동 소수점 값에 사용한다면 컴파일 에러가 발생하다.

상수뿐만 아니라 변수도 피연산자로 사용 가능하다.

* 연산 순서: 우선순위와 결합 방향

  하나의 피연산자에 하나 이상의 연산자가 걸렸을 때 어느 연산자를 먼저 적용할 것인지 결정하는 우선순위 규칙이 있다.

  산술 연산자는 일반 대수학의 우선순위 규칙을 따른다. (덧셈 = 뺄셈 < 곱셈 = 나눗셈 = 나머지셈)

  만약 우선순위가 같다면 결합 방향 규칙을 적용하는데 왼쪽에서 오른쪽결합이므로 왼쪽부터 차례로 계산한다. 이는 하나의 피연산자에 두 개의 연산자가 걸려있을 때만 적용된다.
  
```cpp
int dues = 20 * 5 + 24 * 6;
```

위와 같은 수식이 있을 때 두 개의 언산자가 하나의 피연산자에 걸려있는 상황이 아니므로 결합 방향 규칙을 적용할 수 없다.

실제로 이것은 가장 효율적인 순서가 되도록 C++ 시스템에 맡겨진다.


* 나눗셈에 대한 보충

  나눗셈 연산자는 두 피연산자가 모두 정수이면 정수 나눗셈을 수행한다. 즉, 결과의 소수부를 버리고 정수로 만든다. 그것이 아니라면 부동 소수점수가 된다.


* 나머지셈 연산자

  나머지셈 연산자는 정수 나눗셈의 나머지를 리턴한다.


* 데이터형 변환

  C++은 열한 가지의 정수형과 세가지의 부동 소수점이 있기 때문에, 이들을 혼합여 사용하면 컴퓨터는 여러 가지 처리를 해야한다.

  C++는 데이터형의 불일치를 해결하기 위해 다음과 같은 상황에서 자동으로 데이터형 변환을 수행한다.

  > 특정 데이터형의 변수에 다른 데이터형의 값을 대입했을 때
  
  > 수식에 데이터형을 혼합하여 사용했을 때
  
  > 함수에 매개변수를 전달할 때
  

**대입 구문에서의 데이터형**

so_long이 long형이고 thirty가 short형이라고 할 때

```cpp
so_long = thirty;    // long형 변수에 short형 값을 대입
```

thirty의 short형 값을(대개 16비트) long형 값(대개 32비트)으로 확장하여 so_long에 대입

범위가 작은 데이터형의 값을 큰 데이터형에 대입하는 것은 문제가 되지 않지만 반대면 정밀도가 손실된다.

**{}를 사용할 경우 초기화 변환(C++11)**

C++11은 중괄호를 이용하여 리스트 초기화를 할 수 있다

변수형이 대입된 값으로 표현할 수 없을 경우 리스트 초기화는 narrowing을 허용하지 않는다.(큰 범위에서 작은 범위일때)


**수식에서의 데이터형 변환**

자동 데이터형 변환이란 어떤 수식의 값을 평가할 때 bool, char, unsigned char, signed char, short형 값은 모두 int형으로 변환된다.

ex) true는 1, false는 2

```cpp
short chickens = 20;
short ducks = 35;
short fowl = chickens + ducks;
```

위 코드의 세 번째 행에 있는 구문을 실행하기 위해 C++프로그램은 chickens와 ducks의 값을 int형으로 변환 후에 더한다. 그 후 결과를 short형으로 다시 변환하여 short형 변수 fowl에 대입한다.


일반적으로 컴파일러는 산술식에서 어떤 데이터형 변환이 이루어져야 하는지 검사한다.

다음은 C++11 버전에서 컴파일러가 검사를 진행하는 순서이다.

1. 한쪽 피연산자가 long double형이면, 상대편 피연산자를 long double형으로 변환한다.

2. 그렇지 않고 한쪽 피연산자가 double형이면, 상대편 피연산자를 double형으로 변환한다.

3. 그렇지 않고 한쪽 피연산자가 float형이면, 상대편 피연산자를 float형으로 변환한다.

4. 그렇지 않다면 피연산자들이 정수형이므로 정수 승급이 일어난다.

5. 이 경우에는, 양쪽 피연산자가 모두 signed이거나 모두 unsinged일 결우에는 두 피연산자의 상대적 크기에 따라 큰 쪽으로 변환한다.

6. 반면에 한쪽 피연산자가 singned이고 다른 쪽이 unsigned일 경우, unsigned 피연산자가 signed 피연산자보다 상대적으로 크다면 unsigned 피연산자의 형으로 변환한다.

7. 그렇지 않고 signed형이 unsigned형의 모든 값을 표현할 수 있다면, unsigned 피연산자가 signed형으로 변환된다.

8. 위 5, 6, 7에 해당되지 않는 경우에는 양쪽 피연산자 모두 signed형의 unsigned버전으로 변환한다.


**매개변수를 전달할 때의 형 변환**

일반적으로 함수에 매개변수를 전달할 때 일어나는 데이터형 변환은 C++의 함수 원형이 제어한다.

**데이터형 변환자**

C++에서는 데이터형 변환자를 사용하여 강제로 데이터형을 변환시킬 수 있다.

데이터형 변환자는 다음 두 가지 형태이다.

```cpp
(typeName) value    // value를 typeName형으로 강제로 변환.
typeName (value)    // value를 typeName형으로 강제로 변환.
```

ex) thorn 변수에 저장된 int형 값을 long형으로 강제 변환

```cpp
(long) thorn    // thorn의 long형 변환을 리턴한다.
long (thorn)    // thorn의 long형 변환을 리턴한다.
```

* C++11에서의 auto 선언

  초기화 선언 시 데이터형을 쓰지 않고 auto를 사용할 수 있다.

```cpp
auto n = 100;    // n은 int
auto x = 1.5;    // x는 double
auto y = 1.3e12L  // y는 long double
```

자동으로 데이터형을 추론하는 것은 자동 형환시에 문제가 생길 수 있어 남용해서는 안된다.

## 04장 복합 데이터형

복합 데이터형은 기본 정수형과 부동 소수점형으로부터 만들어진다. 이중 가장 복잡한 것은 클래스이다. 또 배열, 구조체, 포인터 등이 있다.

### 04.1 배열

배열이란 데이터형이 같은 여러개의 값을 연속적으로 저장할 수 있는 데이터 구조이다.

배열은 선언 구문을 사용하여 생성한다. 배열 선언 구문에서는 다음과 같은 세 가지를 선언한다.

> 각 원소에 저장될 값의 데이터형

> 배열의 이름

> 배열 원소의 개수

일반적인 형식은 다음과 같다.

```cpp
typeName arrayName[arraySize];
```

프로그램이 실행되는 동안에는 값이 결정되는 변수는 arraySize가 될 수 없다.

각각의 배열 원소에 개별적으로 접근할 수 있는데, 개별적인 접근을 허용하기 위해 인덱스를 사용하여 배열 원소에 차례로 번호가 매겨진다.

C++의 배열 인덱스는 항상 0부터 시작한다.

또, 대괄호 안에 인덱스를 넣어 배열 원소를 지정한다.

ex) months[0]. months[11]

마지막 인덱스는 항상 배열의 크기보다 1작다.

```cpp
// arrayone.cpp -- 정수형의 작은 배열
#include <iostream>
int main()
{
  using namespace std;
  int yams[3];    // 3개의 원소를 가진 배열을 생성
  yams[0] = 7;
  yams[1] = 8;
  yams[2] = 6;

  int yamcosts[3] = {200, 300, 50};    // 배열을 생성하고 초기화
  
  cout << "고구마 합계 = ";
  cout << yams[0] + yams[1] + yams[2] << endl;
  cout << yams[1] << "개가 들어 있는 포장은 ";
  cout << "개당 " << yamcosts[1] << "원씩입니다.\n";
  int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
  total = total + yams[2] * yamcosts[2];
  cout << "세 포장의 총 가격은 " << total << "원입니다.\n";
  cout << "\nyams 배열의 크기는 " << sizeof yams;
  cout << "바이트입니다.\n";
  cout << "원소 하나의 크기는 " << sizeof yams[0]l
  cout << "바이트입니다.\n";
  return 0;
}

실행결과는 다음과 같다.

```
고구마 합계 = 21
8개가 들어 있는 포장은 개당 300원씩입니다.
세 포장의 총 가격은 4100원입니다.

yams 배열의 크기는 12바이트입니다.
원소 하나의 크기는 4바이트입니다.
```

* 프로그램 분석

이 프로그램은 yams 배열의 세 원소에 고지식한 방법으로 값을 대입했다. 선언 구문에서 배열 원소를 직접 초기화하는 것이 더 용의하다.(아래의 코드와 같이)

```cpp
int yamcosts[3] == {200, 300, 50};
```


* 배열 초기화 규칙

  초기화 형식은 배열을 정의하는 곳에서만 사용할 수 있다.

```cpp
int cards[4] = {3, 6, 8, 10};    // 가능
int hand[4];    // 가능
hand[4] = {5, 6, 7, 9}    // 불가능
hand = cards    // 불가능
```

인덱스를 사용해 배열 원소에 개별적으로 값을 대입하는 것은 언제든지 가능하다.

배열을 초기화할 때 초기화 값의 개수를 배열의 원소의 개수보다 적게 제공해도 된다.(꼭 모든 원소를 정의하지 않아도 된다)

```cpp
float hotelTips[5] = {5.0, 2.5};
```

부분적으로 초기화하면 컴파일러가 나머지 원소들을 0으로 설정한다.

배열을 초기화할 때 대괄호 속을 비워 두면 컴파일러가 초기화 값의 개수를 헤아려 배열 원소의 개수를 결정한다.

```cpp
short things[] = {1, 5, 4, 8}
```

배열 원소의 개수가 4개인 short형의 배열 things를 생성한다.


* C++11 배열 초기화

  첫 째, 배열을 초기화할 때 = 부호를 사용하지 않아도 된다.

```cpp
double earnings[4] { 1.2e4, 1.6e4, 1.1e4, 1.7e4 };
```

  둘 째, 중괄호를 공백으로하여 모든 배열을 초기화할 수 있다.

```cpp
unsigned int counts[10] = { };
float balances[100] { };
```

  셋 째, 리스트 초기화시에 narrowing을 방지할 수 있다.

```cpp
long plifs[ ] = { 25, 92, 3.0};    // 허용 안됨
char slifs [4] { 'h', 'i', 1122011, '\0' };    // 허용 안됨
char tlifs [4] { 'h', 'i', 112, '\0' };    // 허용
```

  plifs[ ]는 부동 소수점형에서 정수형으로 변환되기 때문에 초기화가 실패하게 된다.

  slifs[4]는 1122011이 char 변수가 가지는 크기를 넘어서기 때문에 초기화에 실패하게 된다.

  tlifs[4]는 112가 int 값이지만 char 변수가 가지는 크기를 넘지 않기에 초기화가 성공한다.



### 04.2 문자열

문자열이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말한다.

c++은 두가지 방법으로 문자열을 처리한다.

첫 번째는 C 스타일의 문자열 처리 방법이다.

모든 문자열의 마지막 문자는 **반드시** 널 문자여야한다.

널 문자는 \0으로 쓰며, ASCII 코드가 0인 문자이다.

C++는 cout이 사용하는 함수들도 포함하여, 많은 문자열 처리 함수를 가지고 있는데, 이 함수들은 널 문자를 만날 때까지 문자 단위로 문자열을 처리한다.

```cpp
char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};
```

cat 배열은 char형의 배열을 문자열로 초기화하기 위해 번거로운 방법을 사용한다.

char형의 배열을 문자열로 초기화하는 좋은 방법이 있다.

```cpp
char bird[11] = "Mr. cheeps";    // \0을 저장
char fish[] = "Bubbles"    // 컴파일러가 알아서 처리
```

큰따옴표로 묶인 문자열은 끝내기 널 문자를 암시적으로 가지고 있다.

문자열 상수와 문자 상수는 서로 바꾸어 쓸 수 없다.

ex) "S"는 두개의 문자(S와 \0)으로 구성된 문자열 'S'는 ASCII 시스템에서 83이다.


* 문자열 상수의 결합

  문자열이 너무 길어 한행에 표현이 안될 때 C++에서는 문자열 상수들을 결합할 수 있다.

  이때 결함된 문자열에는 어떠한 빈칸도 추가되지 않는다.

  첫 번째 문자열의 \0가 두 번째 문자열의 첫 문자로 대체된다는 말이다.


* 배열에 문자열 사용

  배열에 문자열을 넣는 가장 일반적인 방법은 다음 두 가지이다.

  1. 배열을 문자열 상수로 초기화하는 방법
 
  2. 키보드 입력이나 파일 입력을 배열에 저장하는 방법
 

* 문자열 입력

```cpp
// instr1.cpp -- 여러 개의 문자열을 읽는다
#include <iostream>
int main()
{
  using namespace std;
  const int ArSize = 20;
  char name[ArSize];
  char dessert[ArSize];

  cout << "이름을 입력하십시오: \n";
  cin >> name;
  cout << "좋아하는 디저트를 입력하십시오: \n";
  cin >> dessert;
  cout << "맛있는 " << dessert;
  cout << " 디저트를 준비하겠습니다. " << name << " 님!\n";
  return 0;
}
```

아래는 위 코드를 실행한 예이다

```
이름을 입력하십시오:
AListair Dreeb
좋아하는 디저트를 입력하십시오:
맛있는 Dreeb 디저트를 준비하겠습니다. Alistair 님!
```

이 프로그램은 디저트를 입력하라는 프롬프트에 응답할 수 있는 기회를 주지 않고 곧 바로 마지막줄까지 출력해 버린다.

cin은 빈칸, 탭, 캐리지 리턴과 같은 화이트스페이스가 있으면 그 위치에서 문자열이 끝난 것으로 간주한다.

> cin은 Alistair를 첫 번재 문자열로 읽어 name 배열에 저장한다. Dreeb은 입력 큐에 그대로 남겨 놓는다.
>
> 좋아하는 디저트 응답을 얻기 위해 cin이 다시 입력 큐를 검사할 때 입력큐에 남아있던 Dreeb을 두 번째 문자여로 읽어서 dessert 배열에 저장한다.


* 한번에 한 행의 문자열 입력 읽기

  단어 단위의 문자열 입력이 아닌 행 단위의 문자열 입력이 필요할 때 istream 클래스가 행 단위로 문자열을 입력하는 클래스 멤버 함수인 getline()과 get()을 제공한다.

  getline()은 개행 문자를 읽어 폐기하는 반면, get()은 입력 큐에 개행 문자를 남겨 둔다.

  **getline()을 이용한 행 단위 입력**

  getline() 함수는 Enter 키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다.

  cin.getline()함수는 두개의 매개변수를 사용하는데 첫 매개변수는 입력한 행을 저장할 배열의 이름이며, 두 번째 매개변수는 입력받을 문자들의 한계이다.

```cpp
cin.getline(name, 20);
```

한 행 전체를 읽고 name 배열에 저장하는데 행에 있는 문자들의 개수는 최대 19개이다.

```cpp
// instr2.cpp -- getline() 함수로 한 행을 읽는다
#include <iostream>
int main()
{
  using namespace std;
  const int ArSize = 20;
  char name[ArSize];
  char dessert[ArSize];

  cout << "이름을 입력하십시오: \n";
  cin.getline(name, ArSize);
  cout << "좋아하는 디저트를 입력하십시오: \n";
  cin.getline(dessert, ArSize);
  cout << "맛있는 " << dessert;
  cout << " 디저트를 준비하겠습니다. " << name << " 님!\n";
  return 0;
}
```

아래는 위 코드를 실행한 예이다

```
이름을 입력하십시오:
Dirk Hammernose
좋아하는 디저트를 입력하십시오:
Radish Torte
맛있는 Radish Torte 디저트를 준비하겠습니다. Dirk Hammernose님!
```

빈칸으로 분리되어 있어도 온전하게 하나로 읽는다.


  **get()을 이용한 행 단위 입력**

  istream 클래스는 또 다른 멤버 함수 get()을 제공한다.

  이 함수는 여러 변종이 있고 그 중의 하나가 getline() 함수처럼 동작한다.
  
  하지만 이 함수는 개행 문자를 읽어서 버리지 않고 입력 큐에 남겨 둔다.

```cpp
cin.get(name, ArSize)
cin.get(dessert, ArSize)  // 문제 발생
```

  첫 호출이 입력 큐에 개행 문자를 그대로 남겨둬 두 번째 호출은 그 개행 문자를 읽고 끝에 도달했다고 결론을 내려버린다.

  cin.get() 호출은 그것이 개행 문자든 아니든 무조건 문자 하나를 읽어 처리한다.

```cpp
cin.get(name, ArSize)    // 첫 번째 행을 읽음
cin.get()    // 개행 문자를 읽음
cin.get(dessert, ArSize)  // 두 번째 행을 읽음
```

다음과 같이 사용할 수 있다.

```cpp
cin.get(name, ArSize).get();
```

  **빈 행과 기타 문제점**

  계속되는 입력을 막고, 입력을 복원하려면 다음과 같은 명령을 사용해야 한다.

```cpp
cin.clear();
```

  또 다른 문제는 입력 문자열이 대입된 공간보다 더 길 수 있다는 것이다. 
  
  입력 행이 지정된 문자 수 보다 길면, getline()과 get()은 나머지 문자를 입력 큐에 그대로 남겨 둔다.


* 문자열과 수치의 혼합 입력

  행 단위의 문자열 입력과 수치 입력을 혼합하여 사용하면 문제가 발생할 수 있다.

```cpp
// numstr.cpp -- 수치 입력 뒤에 오는 문자열 입력
#include <iostream>
int main()
{
  using namespace std;
  cout << "지금 사시는 아파트에 언제 입주하셨습니까?\n";
  int year;
  cin >> year;
  cout << "사시는 도시를 말씀해 주시겠습니까?";
  char address[80];
  cin.getline(address, 80);
  cout << "아파트 입주 연도: " << year << endl;
  cout << "도시: " << address < endl;
  cout << "등록이 완료되었습니다!\n";
  return 0;
}

다음은 실행 예이다.

```
지금 사시는 아파트에 언제 입주하셨습니까?
**1966**
사시는 도시를 말씀해 주시겠습니까?
아파트 입주 연도: 1966
도시: 
등록이 완료되었습니다!
```

이 프로그램은 주소를 입력할 기회를 주지 않는다.

cin이 입주 연도를 읽어들이고 Enter 키가 만들어 내는 개행 문자를 입력 큐에 남겨 두기 때문에 발생한 문제이다.

이 문제를 해결하는 방법은 주소를 읽기 전에 개행 문자를 읽어 허공에 버리는 것이다.

```cpp
cin >> year;
cin.get();
```

또는

```cpp
(cin >> year).get();


### 04.3 string 클래스

string 클래스를 사용하려면, 프로그램에 string 헤더 파일을 포함시켜야 한다.

string 클래스는 std 이름 공간에 속해 있으므로 using 지시자를 사용하거나 std::string을 사용하여 클래스를 참조해 줘야 한다.

string 객체를 문자 배열과 동일한 방식으로 사용할 수 있다.

> C 스타일 문자열로 string 객체를 초기화할 수 있다.

> cin을 사용하여 string 객체에 키보드 입력을 저장할 수 있다.

> cout을 사용하여 string 객체를 디스플레이할 수 있다.

> 배열 표기를 사용하여 string 객체에 저장되어 있는 개별적인 문자들에 접근할 수 있다.

string 객체와 문자 배열의 가장 큰 차이점은 string 객체를 배열이 아니라 단순한 변수로 선언하는 것이다.

```cpp
string str1;    // 빈 string 객체를 생성
string str2 = "panther"    // 초기화된 string 객체를 생성
```


* 대입, 결합, 추가

  string 클래스는 배열보다 조작이 간단하다.

```cpp
char charr1[20];
char charr2[20] = "jaguar";
string str1
string str2 = "panther";
charr1 = charr2;    // 불가능, 배열 대입 안됨
str1 = str2;    // 가능, 객체 대입 가능
```

  string 클래스는 문자열 결함을 간단하게 처리한다.

```cpp
string str3;
str3 = str1 + str2;    // 결합된 두 string 객체를 str3에 대입
str1 += str2;    // str1 끝에 str2를 추가
```

* string 클래스의 조작

  string 클래스가 추가되기전에도 문자열 대입과 같은 조작들을 수행할 필요가 있었다.

```cpp
strcpy(charr1, charr2);    // charr2를 charr1에 복사
strcat(charr1, charr2);    // charr2의 내용을 charr1에 추가
int len1 = str1.size();    // str1의 길이를 구한다.
int len2 = strlen(charr1)  // charr1의 길이를 구한다.
```


* string 클래스의 입출력

  cin을 >> 연산자와 사용하여 string 객체를 읽고, cout을 << 연산자와 사용하여 string 객체를 출력할 수 있다.

  하지만 한 단어가 아닌 한 행을 읽을 때는 다른 문법을 사용한다.

```cpp
getline(cin,str);
```

  도트가 없는걸로 보아 클래스 메서드가 아니다.

  또 매개면수로 cin을 사용한다.

* 다른 형태의 문자열 상수

  C++은 문자열 상수를 초기화하기 위해 L, u, U의 접두사를 가지고 있다.


### 04.4 구조체

구조체는 서로 관련된 정보를 하나의 단위로 묶어 저장한다.

C++에서 구조체는 객체 지향 프로그래밍의 핵심인 클래스의 기초가 된다.

구조체는 사용자가 정의할 수 있는 데이터형이다.

데이터형의 특성을 정의하는 구조체 선언이 필요하다.

그 후에는 데이터의 변수를 생성할 수 있다.

따라서 구조체는 두 단계를 거쳐 생성된다.

1. 구조체 서술을 정의하는 단계: 구조체 안에 저자할 여러 가지 테이터형들을 서술하고 이름을 정한다.

2. 구조체 서술에 따라 구조체 변수를 생성하는 단계: 구조체 데이터 객체를 생성


* 프로그램에 구조체 사용하기

```cpp
structur.cpp -- 간단한 구조체
#include <iostream>
struct inflatable    // 구조체 선언
{
  char name[20];
  float volume;
  double price;
};

int main()
{
  using namespace std;
  inflatable guest =
  {
    "Glorious Gloria",    // name 값
    1.88,    // volume 값
    29.99    // price 값
  };


  inflatable pal =
  {
    "Audacious Arthur",    // name 값
    3.12,    // volume 값
    32.99    // price 값
  };

  cout << "지금 판매하고 있는 모형 풍선은\n" << guest.name;
  cout << "와 " << pal.name << "입니다.\n";

  cout << "두 제품을 $";
  cout << guest.price + pal.price << "에 드리겠습니다!\n";
  return 0;
}
```

  다음은 위의 코드의 실행입니다.

```
지금 판매하고 있는 모형풍선은
Glorious Gloria와 Audacious Arthur입니다.
두 제품을 $62.98에 드리겠습니다!
```

  구조체 선언을 두는 위치는 위 코드에서는 두 가지 방법이 있다.

  1. main() 함수의 안에 여는 중괄호 바로 뒤에 선언을 두는 것

  2. 예제처럼 main() 함수 앞에 선언을 두는 것

  내부적으로 선언을 두면 그 선언이 들어 있는 함수에서만 사용 가능하므로 주의해야한다.

* 구조체의 기타 특성

  대입 연산자를 사용하여 하나의 구조체를 같은 데이터형의 다른 구조체에 대입할 수 있다.

* 구조체의 배열

inflatable 구조체는 배열을 멤버로 포함한다.

```cpp
inflatable gifts[100];    // inflatable형 구조체 100개의 배열
```


* 구조체 안의 비트 필드

  구조체 멤버들이 각각 일정 비트 수를 차지하도록 지정할 수 있다.

  사용할 비트수는 콜론(:)을 찍고 그 뒤에 적으면 된다.



### 04.5 공용체

공용체(union)란 서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식이다.

구조체는 한번에 여러 데이터형을 보관할 수 있지만 공용체는 한 번에 여러 데이터형중에 하나만 보관할 수 있다는 뜻이다.


### 04.6 열거체

C++의 enum 기능은 const를 사용하여 기호 상수를 만드는 것에 대한 또 다른 방편을 제공하다.

enum을 사용하는 구문은 구조체 구문과 비슷하다.

```cpp
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
```

이 구문은 두 가지 일을 수행한다.

1. spectrum을 새로운 데이터형의 이름으로 만든다. struct형 변수를 구조체라 부르듯이, enum형 변수를 열거체라 부른다.

2. red, orange...등을 0에서 7까지의 정수 값을 각각 나타내는 기호 상수로 만든다. 이상수들을 열거자라 부른다.

열거체 변수에는 그 데이터형을 정의하는 데 사용된 열거자 값들만 대입할 수 있다.

```cpp
spectrum band;
band = blue;    // 가능
band = 2000;    // 불가능, 2000은 열거자가 아님
```


* 열거자 값의 설정

  대입 연산자를 사용하여 열거자의 값을 명시적으로 지정할 수 있다.

```cpp
enum bits {one = 1, two = 2, four = 4, eight = 8};
```

  대입되는 값들은 정수만 가능하다.

  또, 하나 이상의 열거자들이 같은 값을 가질 수 있다.


* 열거체의 값 범위

  각 열거체는 값 범위를 가진다.

  어떤 정수값이 그 범위 안에 들어 있으면 열거자 값이 아니더라고 데이터형 변환을 통하여 열거체 변수에 대입할 수 있다.
  

### 04.7 포인터와 메모리 해제

포인터는 값 자체가 아닌 값의 주소를 저장하는 변수이다.

일반적인 변수는 앞에 주소연산자(&)를 붙이면 변수의 주소를 알 수 있다.

16진수 표기가 메모리를 나타내는 가장 일반적인 방법이다.

* 포인터의 선언과 초기화

  컴퓨터는 포인터가 지시하는 값의 데이터형을 추적할 필요가 있.

```cpp
int * p_updates;
```

  \* p_updates가 int형이라는 것을 나타낸다.

  \* 연산자 앞뒤에는 빈칸이 있어도 되고 없어도 된다.

  C++ 프로그래머들은 다음과 같은 형식을 사용하고 있다.

```cpp
int* ptr;    // int* 자체가 하나의 데이터형임을 강조
```

```cpp
int* p1, p2;
```

위와 같은 코드는 p1을 포인터 변수로, p2는 보통의 int형 변수로 생성므로 각각의 포인터 변수 이름 앞에 \* 연산자를 따로 사용해야한다.

```cpp
int higgen = 5;
int * pt = &higgen;
```

선언 구문을 사용하여 포인터를 초기화할 수 있다.

이 경우에는 포인터에 의해 지시되는 값(\*pt)이 아니라 포인터(pt)가 초기화된다.


* 포인터의 위험

  포인터를 생성하면 컴퓨터는 주소를 저장하기 위한 메모리를 대입한다.

```cpp
long * fellow;    // long형을 지시하는 포인터 생성
*fellow = 223323;    // 어딘지 알 수 없는 곳에 값을 저장
```

  여기서 fellow는 포인터 인데, 주소를 대입하는 단계가 빠져 223323이 어디에 저장되었는지 모른다.

  임의의 fellow 주소값에 223323이 저장된 것이다.


* 포인터와 수

  일반적으로 컴퓨터가 주소를 정수로 다루지만 포인터는 개념적으로 정수형과 다른 데이터형이다.

  정수는 덧셈, 뺄셈, 나눗셈 등을 수랳할 수 있는 수지만 포인터는 위치는 나타내는 것이다.

  따라서 포인터에 정수를 직접 대입할 수는 없다.

  어떤 수를 주소로 사용하려면 데이터형 변환자를 사용하여 주소형으로 반드시 변환해 주어야한다.

```cpp
int * pt;
pt = (int *) 0xB8000000;    // 데이터형 일치
```


* new를 사용한 메모리 대입

  지금까지 포인터들을 변수의 주소로 초기화했다.

  각 포인터는 이름에 의해 직접 접근할 수 있는 메모리를 위한 대용 이름을 단순히 제공한다.

  그러나 프로그램을 실행하는 동안 이름이 없는 메모리를 대입하는 것이 포인터의 가치이다.

  어떤 데이터형의 메모리를 원하는지 new 연산자에게 알려 주면, new 연산자는 그에 알맞는 크기의 메모리 불록을 찾아 그 주소를 리턴한다.

  이 주소를 포인터에 대입하면 된다.

```cpp
int * pn = new int;
```

일반적인 형식은 다음과 같다.

```cpp
typeName * pointer_name = new typeName;
```

* delete를 사용한 메모리 해제

  사용한 메모리를 다시 메모리 풀로 환수하는 역활을 하는 것이 delete 연산자이다.

```cpp
int * ps = new int;    //new로 메모리 대입
...    // 메모리 사용
delete ps;    // delete로 메모리 해제
```


* new를 사용한 동적 배열의 생성

  포인터가 하나의 값이 아닌, 배열, 문자열, 구조체와 같이 커다란 데이터를 다룰 때는 new를 사용하는 것이 효율적이다.

  예를 들어 프로그램이 실행되는 동안 주어진 정보에 따라 배열을 생성하거나 생성하지 않는 프로그램을 작성한다 해보자.
  
  선언에 의해 배열을 생성하면 프로그램이 컴파일될 때 배열을 위한 메모리가 대입된다.

  이때 이 배열은 사용되든 안되든 항상 메모리를 차지한다.

  이 방식을 정적 바인딩이라고 한다.

  그러나 new를 사용하면 배열을 실행 시간에 생성하고, 필요하지 않으면 생성하지 않을 수 있다.

  이 방식을 동적 바인딩이라 한다.

  또 이때 생성된 배열을 동적 배열이라고 한다.

  동적 배열에 두 가지 기본 사항이 있다.

  new를 사용한 동적 배열의 생성
 
  배열 원소의 데이터형과 개수를 new에 알려주면된다.

  ```cpp
  int * psome = new int [10];    // 10개의 int형 값을 저장할 블록을 대입
  ```

  new 연산자는 그 블록의 첫 번째 원소의 주소를 리턴한다.

  new를 사용하여 생성된 메모리 블록은, 프로그램이 사용을 끝낸 후에 반드시 delete로 해제해 주어야 한다.

  ```cpp
  delete [] psome;    // 대괄호가 사용되었기 때문에 첫 번째 원소가 해제되는 것이 아니라 배열 전체가 해제
  ```

  new와 delete를 사용할 때 다음과 같은 규칙을 지켜야 한다.

  > new로 대입하지 않은 메모리는 delete로 해제하지 않는다.

  > 같은 메모리 블록을 연달아 두 번 delete로 해제하지 않는다.

  > new []로 메모리를 대입한 경우에는 delete []로 해제한다.

  > new를 대괄호 없이 사용했으면 delete도 대괄호 없이 사용한다.

  > 널 포인터에는 delete를 사용하는 것이 안전하다(아무 일도 일어나지 않는다).

  동적 배열의 사용

  C++이 배열을 구현할 때 내부적으로 포인터를 사용하기 때문에 psome[0], psome[1] 처럼 원소에 접근할 수 있다.


### 04.8 포인터, 배열, 포인터 연산

new 연산자를 사용하여 동적 배열을 생성하고, 포인터를 사용하여 그 배열의 원소에 개별적으로 접근하는 것은 포인터를 배열 이름처럼 사용하면 된다.

* 포인터에 관한 요약

  **포인터 선언**

  ```cpp
  typeName * pointerName;
  ```

  **포인터 값 대입**

  포인터에는 메모리 주소를 대입해야한다.

  변수 이름에 & 연산자를 적용하면 이름이 있는 메모리 주소를 얻고, new 연산자는 이름이 없는 메모리 주소를 리턴한다.

  **포인터의 간접 참조**

  포인터가 지시하는 주소에 저장되어 있는 값을 참조한다는 뜻이다.

  간접 참조 연산자라 불리는 \* 연산자를 포인터에 적용하면 주소에 저장되어 있는 값을 참조할 수 있다.

  **포인터와 참조값의 구별**

  pt가 int형을 지시하는 포인터라면, \*pt는 int형을 지시하는 포인터가 아닌 int형 변수와 완전히 동등한 것이다.

  **배열 이름**

  C++의 배열 이름을 그 배열의 첫 번째 원소의 주소와 동등한 것으로 취급한다.

  **포인터 연산**

  포인터에 정수를 더할 수 있다.

  1을 더하는 것은 원래 주소 값에 포인터가 지시하는 데이터 객체의 크기를 더하는 것과 같다.

  **배열의 동적 바인딩과 정적 바인딩**

  정적 바인딩으로 배열 크기가 고정된 배열을 생성할 때에는 배열 선언 구문을 사용할 수 있다.

  동적 바인딩으로 동적 배열을 생성할 때에는 new연산자를 사용한다.

  프로그램이 실행될 때 배열의 크기가 정해지고 메모리를 대입받는다.

  배열을 사용하는 작업이 끝나면 delete []로 메모리를 해제해야한다.

  **배열 표기와 포인터 표기**

  대괄호를 사용하는 배열 표기는 포인터를 사용하는 간접 참조와 의미상 동등하다.


* 포인터와 문자열

  배열 이름이 배열의 첫 번째 원소를 나타내듯이, 큰따옴표로 둘러싸인 문자열은 그 문자열의 첫 번째 문자의 주소를 나타낸다.

  즉, char형의 배열에 저장된 문자열, 큰따옴표로 둘러싸인 문자열 상수, 포인터로 참조되는 문자열이 모두 동등하게 취급된다는 뜻이다.

* new를 사용한 동적 구조체의 생성

  구조체 또한 실행 시간에 배열을 생성하는 것이 유리하다.

  new를 구조체에 사용할 때는 두 가지를 알아야한다.

  하나는 구조체를 생성하는 것이고 다른 하나는 구조체의 멤버에 접근하는 것이다.

  구조체를 생성하려면 구조체형 앞에다 new를 붙이면 된다.

* 자동 공간, 정젹 공간, 동적 공간

  데이터를 저장해 두기 위한 메모리를 대입하는 방법에 따라 자동 공간, 정적 공간, 동작 공간으로 구분한다.

  **자동 공간**

  자동 공간을 사용하는 함수 안에서 정의되는 보통의 변수들을 자동 변수라 한다.

  자동 공간은 자동 변수가 자신이 정의되어 있는 함수가 호출되는 순간에 자동으로 생겨나 함수가 종료되는 시점까지 존재하는 것을 뜻한다.

  자동 변수는 스텍에 저장된다. 즉, 메모리상의 스택에 값이 순차적으로 저장되었다가 역순으로 해제되는 것을 의미한다.

  **정적 공간**

  정적 공간은 프로그램이 실행되는 동안 지속적으로 존재하는 공간을 말한다.

  변수를 정적으로 만드는 것은 두가지다.

  1. 함수의 외부에서 변수를 정의

  2. 변수를 선언할 때 static이라는 키워드를 붙이는 것이다.

  **동적 공간**

  new와 delete 연산자는 자유 공간이라고 부르는 메모리 풀을 관리한다.

  풀은 자동 변수와 정적 변수가 사용하는 메모리와 분리되어 있다.


### 04.9 변수형의 조합

이 장에서는 배열, 구조, 포인터를 소개하였다.

이 세 가지는 매우 다양한 방법으로 조합될 수 있다.


### 04.10 배열의 대안

* Vector 템플릿 클래스

  동적 배열에 속하는 string 클래스와 유사하다.

  기본적으로 동적 배열을 생성하기 위해 new를 사용하는 것을 대체할 수 있다.

> vector객체를 사용하기 위해서는 vector 헤더 파일을 포함해야 한다.

> vector 식별자는 std 이름 공간의 일부분이기 때문에 using 명령, using 선언 또는 std::vector를 사용할 수 있다.

> 템플릿은 저장된 데이터 형태를 지시하기 위해 다른 구문을 사용한다.

> vector 클래스는 원소의 개수를 지칭하기 위해서 다른 구문을 사용한다.


* array 템플릿 클래스(C++11)

  C++11은 array 템플릿 클래스를 더해 줌으로서 내재 배열형을 사용할 수 있다.


* 배열, vector 객체, Array 객체 비교

  > 내재 배열, vector 객체, array 객체 어떤 것이든 사용자는 개별 멤버에 접속하기 위해 표준 배열 표식을 사용할 수 있다.
  
  > 주소를 통해서 array 객페가 동일한 지역의 메모리를 사용한다는 것을 알 수 있다.

  > 반면 vector 객체는 다른 지역에 저장된다(자유 저장 또는 heep).
  
  > 하나의 array 객체를 또 다른 array 객체에 대입할 수 있다.
  
  > 내재 배열에 대하여 데이터를 요소별로 복사해야한다.
  

## 05장 루프와 관계 표현

컴퓨터로 데이터를 처리하려면 반복적인 동작을 수행하거나, 조건을 판단하여 의사를 결정할 수 있는 도구가 필요하다.

### 05.1 for 루프

for 루프를 사용하면 반복 작업을 쉽게 처리할 수 있다.

* for 루프의 각 부분

  1. 조건 검사에 사용할 카운터 값을 초기화 한다.
 
  2. 루프를 진행할 것인지 조건을 검사한다.
    
  3. 루프 몸체를 수행한다.
 
  4. 카운터 값을 갱신한다.

  초기화, 조건 검사, 갱신을 처리하는 for 루프의 세 제어 부분은 괄호로 묶여 있다.

  각각 하나의 표현식이며, 세미콜론(;)에 의해 분리되어있다.

```cpp
for (initialization; test-expression; update-expression)
    body
```

  **표현식과 구문**

  for 루프의 제어 부분은 세 개의 표현식을 사용한다. 어떤 값이나 값과 연산자들의 적절한 조합이 표현식이 될 수 있다.

  표현식을 구문으로 만드는 것은 표현식 끝에 세미콜론만 붙이면 된다.

  **표현식이 아닌 것과 구문**

  어떠한 표현식도 세미콜론만 붙이면 구문이 되지만 역은 항상 성립하지 않는다.

```cpp
int told;
```

  위의 코드는 세미콜론을 없애도 표현식이 될 수 없다

  **융통성 있는 규칙**

  for 루프의 초기화 부분에 변수를 선언할 수 있다.

  선언은 표현식이 아니지만 이는 허용된다.

* for 루프에 대한 보충

  for 루프와 배열을 결합하여 배열의 원소에 차례대로 접근할 수 있다.


* 갱신 크기 변경

  i++ 대신 갱신 표현식을 변경해 루프 카운터가 갱신되는 크기를 바꿀 수 있다.


* for 루프를 사용한 문자열 처리

  for 루프를 사용하여 문자열을 구성하는 문자들에 차례대로 접근할 수 있다.


* 증가 연산자(++)와 감소 연산자(--)

  증가 연산자는 루프 카운터를 1씩 증가시키고, 감소 연산자는 루프카운터를 1씩 감소시킨다.

  이 두 연산자 모두 접두어 방식과 접미어 방식으로 사용할 수 있는데 연산을 적용하는 시점이 다르다.

  ex) a++는 a가 현재 가지고 있는 값으로 표현식을 먼저 평가한 후, a의 값을 나중에 증가 시킨다.
    ++b는 b의 값을 먼저 증가시킨 후, 증가된 b의 값으로 표현식의 값을 평가한다.

* 부수 효과와 시퀀스 포인트

  부수 효과는 수식을 평가할 때 변수에 저장되어 있는 값 같은 것이 변경될 때 일어나느 효과를 말한다.

  시퀀스 포인트는 프로그램의 실행이 다음 단계로 넘어가기 전에 모든 부수 효과들이 확실하게 평가가 되는 포인트다.

  구문에 있는 세미콜론은 시퀀스 포인트를 표시한다.

  시퀀스 포인트는 접미어 방식의 증가가 일어나는 시점을 명확히 하는 것을 돕는다.


* 접두어 방식과 접미어 방식

  내장 데이터형에 대해서는 어느 방식을 사용해도 거의 차이가 없다.

  사용자 정의 증가 연산자와 감소 연산자를 사용하는, 사용자 정의 데이터형에 대해서는 접두어 방식이 좀 더 효율적이다.


* 증가/ 감소 연산자와 포인터

  포인터에 증가 연산자를 사용하면 포인터가 지시하는 데이터형의 바이트 수 만큼 그 값을 증가 시킨다. 감소시키는 것에는 동일한 규칙이 적용된다.


* 조합 대입 연산자.

  덧셈과 대입 기능이 하나로 결합된 조합 대입 연산자를 제공한다.

  ```cpp
  i = i + by
  ```

  표현식을 간단하게 다음과 같이 나타낼 수 있다

  ```cpp
  i += by
  ```

  |연산자|효과(L은 왼쪽 피연산자, R은 오른쪽 피연산자)|
  |---|---|
  |+=|L + R을 L에 대입한다|
  |-=|L - R을 L에 대입한다|
  |*=|L * R을 L에 대입한다|
  |/=|L / R을 L에 대입한다|
  |%=|L % R을 L에 대입한다|

  
* 복합 구문 또는 블록

  한 쌍의 중괄호를 사용하여 복합 구문 또는 블록을 만들어 루프 몸체 안에 원하는 만큼의 구문을 넣을 수 있다.

  블록 안에서 새로운 변수를 정의하면 블록을 빠져나오면 그 변수는 사라진다.


* 콤마 연산자

  블록을 통해 여러 개의 구문을 넣을 수 있는 것처럼 표현식에서는 콤마를 통해 여러개의 표현식을 하나의 표현식처럼 넣을 수 있다.

  ```cpp
  ++J, --i
  ```

  **콤마 연산자에 대한 보출**

  콤마 연산자는 첫 번째 표현식을 평가한 후 다음 표현식을 평가한다.

  또, 마지막 표현식을 콤마 표현식 전체의 값으로 만든다.


* 관계 표현식

  |연산자|의미|
  |---|---|
  |<|작다|
  |<=|작거나 같다|
  |==|같다|
  |>|크다|
  |>=|크거나 같다|
  |!=|같지 않다|


### 05.2 while 루프

while 루프는 for 루프에서 초기화 부분과 갱신 부분을 없애고 몸체와 조건 검사 부분만 남겨놓은 것이다

```cpp
while (test-expression)
    body
```


* for와 while

  for 루프와 while 루프는 거의 동등하기 때문에 어느 것을 사용해도 상관 없다.

  루프 설계할 때는 다음과 같은 지침을 고려해야 한다.

  > 루프 실행을 종료시키는 조건을 파악

  > 첫 번째 조건 검사를 하기 전 그 조건을 초기화한다.

  > 조건 검사를 다시 하기 전에 매 루프 주기마다 그 조건을 갱신한다.
  
  for 루프의 장점은 구조상 이 세 가지 지침을 지키기 좋고 기억하기 쉽다는 것이다.


* 잠시만-시간 지연 루프

  시간을 지연시키는 동작을 프로그램 안에 넣어야할 때 while 루프로 이런 효과를 만들어 낼 수 있다.

  ```cpp
  long wait = 0;
  while (wait < 10000)
    wait++;
  ```

  이 방법의 문제점은 컴퓨터 성능에 따라 시간의 지연이 다르다는 것이다.

  ANSI C와 C++ 라이브러리는 이 용도로 clock()이라는 함수는 제공한다.

  이 함수는 두 가지 제약이 있다.

  > 함수가 리턴하는 값은 초 단위가 아니다.
  
  > 이 함수가 리턴하는 데이터형은 어떤 시스템에서는 long형, 다른 시스템에서는 unsigned long형, 또 다른 시스템에서는 또 다른 데이터형일 수 있다.


  이 문제의 해결책으로 ctime 헤더 파일이 있다.

  > 이 헤더 파일은 초당 시스템 시간 단위 수를 알려주는 CLOCKS_PER_SEC라는 기호 상수를 정의한다. clock() 함수가 리턴하는 시스템 시간을 이 상수로 나누면 초 단위의 시간을 얻을 수 있다
  
  > ctime은 clock() 함수가 리턴하는 데이터형의 대용 이름으로 clock_t형을 정의한다.
  

### 05.3 do while 루프

do while 루프는 for 루프나 while 루프와 달리 탈출 조건 루프이다.

루프 몸체를 먼저 실행하고, 조건을 검사한다는 뜻이다.

검사하는 조건이 false로 평가되면 루프가 종료된다.

```cpp
do
    body
while (test-expression);
```

do whil 루프는 조건을 평가하기 전에 루프 몸체를 적어도 한 번은 실행한다


### 05.4 Range 기반의 for 루프(C++ 11)

배열의 range 안에 포함되는 모든 값들이 로프를 돌면서 출력된다.

### 05.5 루프와 텍스트 입력

루프를 적용할 수 있는 가장 일반적이며 중요한 예제로서, 텍스트 입력이 있다.

* cin을 이용한 입력

  키보드로부터 텍스트를 입력받기 위해 루프를 사용할 경우에 프호그램은 입력이 언제 끝나는지 알아야한다.

  한 가지 방법은 표지 문자라고 부르는 특수 문자를 입력 중지 신호로 사용하는 것이다.


* cin.get(char)를 이용한 입력

  일반적으로 문자 단위로 입력을 읽어들이는 프로그램은 빈칸 문자, 탭 문자, 개행 문자까지 포함해서 모든 문자를 읽어들여야한다.

  istream 클래스는 이런 요구를 만족 시키는 멤버 함수들을 가지고 있다.

  cin.get(ch) 멤버 함수는 빈칸 문자까지도 입력받아 ch 변수에 저장한다.


* 파일 끝(End-Of-File) 조건

  C++의 입력 기능은 운영 체제의 도움을 받아 입력이 파일의 끝에 도달했을 때 이를 인식하고, 그 정보를 프로그램에 전달할 수 있다.

  ```cpp
  gofish < fishtale
  ```
  
  gofish 프로그램은 키보드로부터 입력을 받지 않고 fishtale 파일로부터 입력받는다.
  
  cin은 EOF를 탐지했을 때 두 개의 비트(eofbit와 failbit)를 1로 설정한다.

  eof()라는 멤버 함수를 사용하면 eofbit가 설정되었는지 알수 있다.

  **입력을 끝내는 EOF**

  cin 메서드가 EOF를 발견하면, cin 객체에서 EOF 조건을 나타내는 플래그가 설정된다.

  이 플래그가 설정되면 더 이상의 입력을 받아들이지 않는다.


### 05.6 중첩 루프와 2차원 배열

2차원 배열은 행과 열을 모두 가지고 있는 표와 같다.

C++은 2차원 배열을 나타내는 데이터형을 따로 제공하지 않지만 다른 배열을 원소로 사용하는 배열로 만들 수 있다.

* 2차원 배열의 초기화

  ```cpp
  // 1차원 배열의 초기화
  int btus[5] = { 23, 26, 24, 31, 28};
  ```

  ```cpp
  // 2차원 배열의 초기화
  int maxtemps[4][5] =
  {
    {94, 98, 87, 103, 101},
    {98, 99, 91, 107, 105},
    {93, 91, 90, 101, 104},
    {95, 100, 88, 105, 103}
  };
  ```

  for 루프 안에 또 다른 for 루프를 넣어 중첩 루프를 만들어 2차원 배열을 처리할 수 있다.
