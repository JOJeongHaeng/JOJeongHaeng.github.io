---
layout: single
title:  "web-app구현하기"
categories: coding
tag: [python, blog, jekyll]
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


#UFO sighting 에 관한 로지스틱 회귀 모델을 사용하기 위한 웹앱 만들기


# 데이터 정제


1. pandas, matplotlib, numpy를 가져와서 ufos 스프레드시트를 가져옵니다. 샘플 데이터 집합을 살펴볼 수 있습니다:



```python
import pandas as pd
import numpy as np
ufos = pd.read_csv('https://raw.githubusercontent.com/JOJeongHaeng/jeonghaeng.github.io/main/ufos.csv')
ufos.head()
```

<pre>
           datetime                  city state country     shape  \
0  10/10/1949 20:30            san marcos    tx      us  cylinder   
1  10/10/1949 21:00          lackland afb    tx     NaN     light   
2  10/10/1955 17:00  chester (uk/england)   NaN      gb    circle   
3  10/10/1956 21:00                  edna    tx      us    circle   
4  10/10/1960 20:00               kaneohe    hi      us     light   

   duration (seconds) duration (hours/min)  \
0              2700.0           45 minutes   
1              7200.0              1-2 hrs   
2                20.0           20 seconds   
3                20.0             1/2 hour   
4               900.0           15 minutes   

                                            comments date posted   latitude  \
0  This event took place in early fall around 194...   4/27/2004  29.883056   
1  1949 Lackland AFB&#44 TX.  Lights racing acros...  12/16/2005  29.384210   
2  Green/Orange circular disc over Chester&#44 En...   1/21/2008  53.200000   
3  My older brother and twin sister were leaving ...   1/17/2004  28.978333   
4  AS a Marine 1st Lt. flying an FJ4B fighter/att...   1/22/2004  21.418056   

    longitude  
0  -97.941111  
1  -98.581082  
2   -2.916667  
3  -96.645833  
4 -157.803611  
</pre>
2. ufos 데이터를 새로운 제목을 가진 작은 데이터 프레임으로 변환합니다. 국가 필드에서 고유 값을 확인합니다.



```python
ufos = pd.DataFrame({'Seconds': ufos['duration (seconds)'], 'Country': ufos['country'],'Latitude': ufos['latitude'],'Longitude': ufos['longitude']})

ufos.Country.unique()
```

<pre>
array(['us', nan, 'gb', 'ca', 'au', 'de'], dtype=object)
</pre>
이제 null 값을 삭제하고 1~60초 사이의 목격 횟수만 가져와서 처리해야 하는 데이터의 양을 줄일 수 있습니다:



```python
ufos.dropna(inplace=True)

ufos = ufos[(ufos['Seconds'] >= 1) & (ufos['Seconds'] <= 60)]

ufos.info()
```

<pre>
<class 'pandas.core.frame.DataFrame'>
Int64Index: 25863 entries, 2 to 80330
Data columns (total 4 columns):
 #   Column     Non-Null Count  Dtype  
---  ------     --------------  -----  
 0   Seconds    25863 non-null  float64
 1   Country    25863 non-null  object 
 2   Latitude   25863 non-null  float64
 3   Longitude  25863 non-null  float64
dtypes: float64(3), object(1)
memory usage: 1010.3+ KB
</pre>
Scikit-learn의 LabelEncoder 라이브러리를 가져와서 국가별 텍스트 값을 숫자로 변환합니다:



라벨인코더는 데이터를 알파벳순으로 인코딩합니다.



```python
from sklearn.preprocessing import LabelEncoder

ufos['Country'] = LabelEncoder().fit_transform(ufos['Country'])

ufos.head()
```

<pre>
    Seconds  Country   Latitude   Longitude
2      20.0        3  53.200000   -2.916667
3      20.0        4  28.978333  -96.645833
14     30.0        4  35.823889  -80.253611
23     60.0        4  45.582778 -122.352222
24      3.0        3  51.783333   -0.783333
</pre>
#모델 구축


이제 데이터를 학습 그룹과 테스트 그룹으로 나누어 모델 학습을 준비할 수 있습니다.


1. 훈련하려는 세 가지 기능을 X 벡터로 선택하고, Y 벡터는 국가가 됩니다. 초, 위도 및 경도를 입력하고 반환할 국가 ID를 가져올 수 있기를 원합니다.



```python
from sklearn.model_selection import train_test_split

Selected_features = ['Seconds','Latitude','Longitude']

X = ufos[Selected_features]
y = ufos['Country']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
```

2. 로지스틱 회귀를 사용하여 모델을 훈련합니다:



```python
from sklearn.metrics import accuracy_score, classification_report
from sklearn.linear_model import LogisticRegression
model = LogisticRegression()
model.fit(X_train, y_train)
predictions = model.predict(X_test)

print(classification_report(y_test, predictions))
print('Predicted labels: ', predictions)
print('Accuracy: ', accuracy_score(y_test, predictions))
```

<pre>
              precision    recall  f1-score   support

           0       1.00      1.00      1.00        41
           1       0.83      0.24      0.37       250
           2       1.00      1.00      1.00         8
           3       1.00      1.00      1.00       131
           4       0.96      1.00      0.98      4743

    accuracy                           0.96      5173
   macro avg       0.96      0.85      0.87      5173
weighted avg       0.96      0.96      0.95      5173

Predicted labels:  [4 4 4 ... 3 4 4]
Accuracy:  0.9607577807848444
</pre>
<pre>
/usr/local/lib/python3.10/dist-packages/sklearn/linear_model/_logistic.py:458: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  n_iter_i = _check_optimize_result(
</pre>
국가와 위도/경도가 상관관계가 있기 때문에 정확도는 당연히 나쁘지 않습니다(약 95%).



위도와 경도를 통해 국가를 유추할 수 있어야 하기 때문에 만든 모델이 그다지 혁신적이지는 않지만, 정리하고 내보낸 원시 데이터로 학습한 다음 웹 앱에서 이 모델을 사용해 보는 것은 좋은 연습이 됩니다.


#모델 '피클'


이제 모델을 피클할 시간입니다! 몇 줄의 코드로 이 작업을 수행할 수 있습니다. 피클이 완료되면 피클된 모델을 로드하고 초, 위도 및 경도 값이 포함된 샘플 데이터 배열에 대해 테스트합니다,



```python
import pickle
model_filename = 'ufo-model.pkl'
pickle.dump(model, open(model_filename,'wb'))

model = pickle.load(open('/content/ufo-model.pkl','rb'))
print(model.predict([[50,44,-12]]))
```

<pre>
[1]
</pre>
<pre>
/usr/local/lib/python3.10/dist-packages/sklearn/base.py:439: UserWarning: X does not have valid feature names, but LogisticRegression was fitted with feature names
  warnings.warn(
</pre>
## 연습 - Flask 앱 만들기



지금부터 Flask 앱을 만들어서 모델을 부르고 비슷한 결과를 반환하지만, 시각적으로 만족할 방식으로도 가능합니다.



1. C드라이브에 pytion_my_projects폴더를 만든 후 안에 가상 공간을 만들어줍니다. 그 후 폴더에서 3가지 폴더를 만듭니다: **static**, 내부에 **css** 폴더가 있으며, **templates`** 도 있습니다. 다음 파일과 디렉토리들이 있어야 합니다:



    ```output

    web-app/

      static/

        css/

        templates/

    notebook.ipynb

    ufo-model.pkl

    ``` 





1. 가상공간 폴더에서 만들 첫 파일은 **requirements.txt** 파일입니다. JavaScript 앱의 _package.json_ 처럼, 앱에 필요한 의존성을 리스트한 파일입니다. **requirements.txt** 에 해당 라인을 추가합니다:



    ```text

    scikit-learn

    pandas

    numpy

    flask

    ```



![image](https://user-images.githubusercontent.com/118785061/236636445-a4869106-f5f5-45af-94c5-40dd7a38ffee.png)

```pip install -r requirements.txt```

명령어프롬프트에 위 코드를 타이핑합니다.





1. 지금부터, 앱을 완성하기 위해서 3가지 파일을 더 만들 준비를 했습니다:



    1. 최상단에  **app.py**를 만듭니다.

    2. _templates_ 디렉토리에 **index.html**을 만듭니다.

    3. _static/css_ 디렉토리에 **styles.css**를 만듭니다.



1. 몇 스타일로 _styles.css_ 파일을 만듭니다:



    ```css

    body {

    	width: 100%;

    	height: 100%;

    	font-family: 'Helvetica';

    	background: black;

    	color: #fff;

    	text-align: center;

    	letter-spacing: 1.4px;

    	font-size: 30px;

    }

    

    input {

    	min-width: 150px;

    }

    

    .grid {

    	width: 300px;

    	border: 1px solid #2d2d2d;

    	display: grid;

    	justify-content: center;

    	margin: 20px auto;

    }

    

    .box {

    	color: #fff;

    	background: #2d2d2d;

    	padding: 12px;

    	display: inline-block;

    }

    ```



1. 다음으로 _index.html_ 파일을 만듭니다:



    ```html

    <!DOCTYPE html>

    <html>

    <head>

      <meta charset="UTF-8">

      <title>🛸 UFO Appearance Prediction! 👽</title>

      <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}"> 

    </head>

    

    <body>

     <div class="grid">

    

      <div class="box">

    

      <p>According to the number of seconds, latitude and longitude, which country is likely to have reported seeing a UFO?</p>

    

        <form action="{{ url_for('predict')}}" method="post">

        	<input type="number" name="seconds" placeholder="Seconds" required="required" min="0" max="60" />

          <input type="text" name="latitude" placeholder="Latitude" required="required" />

    		  <input type="text" name="longitude" placeholder="Longitude" required="required" />

          <button type="submit" class="btn">Predict country where the UFO is seen</button>

        </form>

    



1. `app.py` 에 추가합니다:



    ```python

    import numpy as np

    from flask import Flask, request, render_template

    import pickle

    

    app = Flask(__name__)

    

    model = pickle.load(open("./ufo-model.pkl", "rb"))

    

    

    @app.route("/")

    def home():

        return render_template("index.html")

    

    

    @app.route("/predict", methods=["POST"])

    def predict():

    

        int_features = [int(x) for x in request.form.values()]

        final_features = [np.array(int_features)]

        prediction = model.predict(final_features)

    

        output = prediction[0]

    

        countries = ["Australia", "Canada", "Germany", "UK", "US"]

    

        return render_template(

            "index.html", prediction_text="Likely country: {}".format(countries[output])

        )

    

    

    if __name__ == "__main__":

        app.run(debug=True)

    ```


명령어 프롬프트에서 가상공간으로 이동후

```

flask run

```

을 입력하면 아래 사진처럼 웹 주소가 뜬다.


![스크린샷 2023-05-07 012135](https://user-images.githubusercontent.com/118785061/236636478-f0464d8a-bc7a-479d-aea9-3537e330ef94.png)



이를 들어가 보면


![스크린샷 2023-05-07 012234](https://user-images.githubusercontent.com/118785061/236636499-3bdbdf34-e112-4512-930e-9ad1105f5064.png)
이와 같은 웹앱을 구현 할 수 있다.

