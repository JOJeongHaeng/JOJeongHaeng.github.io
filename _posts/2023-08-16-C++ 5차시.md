---
layout: single
title:  "2023 C++ 학습하기 4차시"
categories: 
  - Cpp
author_profile: false
toc: true
toc_sticky: true
toc_depth: 2
---

<head>
  <style>   
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# 13장 클래스의 상속

객체 지향의 목적중 하나가 코드의 재활용이다.

C의 전통적인 함수 라이브러리는 미리 정의되어 컴파일된 상태인 strlen()이나 rand()와 같은 함수들을 통해서 재활용성을 제공하고 있다.

C++의 클래스는 클래스 라이브러리를 통해 재활용성을 제공한다.

일반적으로 클래스 라이브러리들은 소스 코드 형태로 제공된다. 따라서 사용자가 자신의요구에 맞게 코드를 수정할 수 있다.

그러나 클래스를 확정하고 수정하기 위해 단순한 코드 수정보다 클래스 상속을 이용하는 것이 더 유용하다.

상속을 통해 다음과 같은 일을 할 수 있다.

* 기존의 클래스에 기능을 추가할 수 있다.

* 클래스가 나타내고 있는 데이터에 다른 것을 추가할 수 있다. Ex) 간단한 문자열 클래스가 있다면 문자열을 출력할 때 사용할 색상을 나타내는 데이터 멤버가 추가된 클래스를 파생시킬 수 있다.

* 클래스 메서드가 동작하는 방식을 변경할 수 있다. Ex) 비행기 승객에게 제공되는 서비스를 나타내는 passenger 클래스가 있다면 고급 서비스를 제공하는 FirstClassPassenger 클래스를 파생시킬 수 있다.


## 13.1 간단한 기초 클래스로부터 시작하자

어떤 클래스를 다른 클래스로부터 상속하려할 때 오리지널 클래스를 기초 클래스, 상속받는 클래스를 파생 클래스라고 한다.

다음 Webtown Social Club은 탁구 동호회의 회원 정보를 관리하기로 결정했다.

```cpp
//tabtenn0.h -- 탁구 기초 클래스
#ifndef TABTEEN0_H_
#define TABTEEN0_H_
#include <string>

using std::string;
// 간단한 기초 클래스
class TableTennisPlayer
{
private:
    string firstname;
    string lastname;
    bool hasTable;
public:
        TableTennisPlayer(const string & fn = "none",
                          const string & ln = "none", bool ht = false);
        void Name() const;
        bool HasTable() const { return hasTable; };
        void ResetTable(bool v) { hasTable = v; };
};
#endif
```

```cpp
//tabtenn0.cpp -- 탁구 기초 클래스
#include "tabtenn0.h"
#include <iostream>

TableTennisPlayer::TableTennisPlayer (const string & fn,
    const string & ln, bool ht) : firstname(fn),
            lastname(ln), hasTable(ht) {}

void TableTennisPlayer::Name() const
{
        std::cout << lastname << ", " << firstname;
}
```

위 클래스가 하는 일은 선수의 이름과 그 선수가 탁구대를 소유하고 있는지 추적하는 것이다.

클래스는 이름을 소유하기 위해 표준 String 클래스를 사용한다. (문자열을 사용하는 것보다 편리하고 탄력적이며 안전하기 때문)

생성자는 초기자 리스트 구문을 사용한다.

```cpp
TableTennisPlayer::TableTennisPlayer (const string & fn,
    const string & ln, bool ht) : firstname(fn),
            lastname(ln), hasTable(ht) {}
```

다음은 클래스가 어떻게 동작하는지를 보여준다.

```cpp
// usett0.cpp -- 기초 클래스를 사용한다
#include <iostream>
#include "tabtenn0.h"

int main()
{
    using std::cout;
    TableTennisPlayer player1("Chuck", "Blizzard", true);
    TableTennisPlayer player2("Tara", "Boomdea", false);
    player1.Name();
    if (player1.HasTable())
        cout << ": 탁구대가 있다.\n";
    else
        cout << ": 탁구대가 없다.\n";
    player2.Name();
    if (player2.HasTable())
        cout << ": 탁구대가 있다.\n";
    else
        cout << ": 탁구대가 없다.\n";
    
    return 0;
}
```

### 클래스 파생시키기

TableTennisPlayer로 부터 원하는 클래스를 파생시킬 수 있다.

```cpp
// RatedPlayer는 TableTennisPlayer 기초 클래스로부터 파생된다.
class RatedPlayer : public TableTennisPlayer
{
...
};
```

콜론은 RatedPlayer 클래스가 TableTennisPlayer 클래스의 기초를 두고 있다는 것을 나타내고, TableTennisPlayer가 public 기초 클래스라는 것을 나타낸다.

이를 public 파생이라 한다. public 파생에서는 기초 클래스의 public 멤버들이 파생 클래스의 public 멤버가 된다. 기초 클래스의 private 부분들도 파생클래스의 일부가 된다.

RatedPlayer 객체를 선언한다면, 그 객체는 다음과 같은 특별한 속성을 가진다.

* 파생 클래스형의 객체 안에는 기초 클래스형의 데이터 멤버들이 저장된다. (파생 클래스는 기초 클래스의 구현들을 상속받는다.)

* 파생 클래스형의 객체는 기초 클래스형의 메서드들을 사용할 수 있다. (파생 클래스는 기초 클래스의 인터페이스를 상속받는다.)

이와 같은 상속받은 기능에 무엇을 추가할 필요가 있을까?

* 파생 클래스는 자기 자신의 생성자를 필요로 한다.

* 파생 클래스는 부가적인 데이터 멤버들과 멤버 함수들을 필요한 만큼 추가할 수 있다.

RatePlayer 파생 클래스에 탁구 대회에서 거둔 랭킹을 저장해보자

이는 하나의 데이터 멤버, 랭킹을 알아내는 메서드, 랭킹을 다시 설정하는 메서드가 필요하다.

```cpp
// 간단한 파생 클래스
class RatedPlayer : public TableTennisPlayer
{
private:
  unsigned int rating;  // 추가 데이터 멤버
public:
    RatedPlayer(unsigned int r = 0, const char * fn = "none",
            const string & ln = "none", bool ht = false);
    RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
    unsigned int Rating() { return rating; } // 추가 메서드
    void ResetRating(unsigned int r) { rating = r; } // 추가 메서드
};
```

생성자들은 새로 추가된 데이터 멤버와 상속받은 데이터 멤버들에 데이터를 제공해야 한다

첫 번째 RatedPlayer 생성자는 각각의 데이터 멤버들에 대해서 개별적인 형식 매개변수를 사용한다.

두 번째 RatedPlayer 생성자는 하나의 TableTennisPlayer 매개변수를 사용한다.

그 매개변수는 세 개의 항목을 하나의 묶음으로 결합한다.


### 생성자: 접근에 대하여

파생 클래스는 기초 클래스의 private 멤버에 직접 접근할 수 없다. 기초 클래스의 메서드들을 통해서 접근해야 한다.

Ex) RatedPlayer 생성자는 상속받은 멤버들을 직접 설정할 수 없다.

프로그램이 파생 클래스의 객체를 생성할 때 먼저, 기초 클래스의 객체를 생성한다.

Ex) 첫 번째 RatedPlayer 생성자의 코드는 다음과 같다.

```cpp
RatedPlayer::RatedPlayer(unsigned int r = 0, const char * fn,
  const string & ln, bool ht = false) : TableTannisPlayer(fn, ln, ht)
{
  rating
}
```

```cpp
: TableTannisPlayer(fn, ln, ht)
```

이 부분이 멤버 초기자 리스트이다. 이때 TableTannisPlayer 생성자를 호출하게 된다.

```cpp
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
```

이 RatedPlayer 생성자는 실제 매개변수인 "Mallory", "Duck", true를 형식 매개변수인 fn, ln, ht에 대입한다. 그 후 형식 매개변수들을 실제 매개변수 자격으로 TableTennisPlayer 생성자에 전달한다. 
