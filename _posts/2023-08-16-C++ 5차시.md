---
layout: single
title:  "2023 C++ 학습하기 5차시"
categories: 
  - Cpp
author_profile: false
toc: true
toc_sticky: true
toc_depth: 2
---

<head>
  <style>   
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# 13장 클래스의 상속

객체 지향의 목적중 하나가 코드의 재활용이다.

C의 전통적인 함수 라이브러리는 미리 정의되어 컴파일된 상태인 strlen()이나 rand()와 같은 함수들을 통해서 재활용성을 제공하고 있다.

C++의 클래스는 클래스 라이브러리를 통해 재활용성을 제공한다.

일반적으로 클래스 라이브러리들은 소스 코드 형태로 제공된다. 따라서 사용자가 자신의요구에 맞게 코드를 수정할 수 있다.

그러나 클래스를 확정하고 수정하기 위해 단순한 코드 수정보다 클래스 상속을 이용하는 것이 더 유용하다.

상속을 통해 다음과 같은 일을 할 수 있다.

* 기존의 클래스에 기능을 추가할 수 있다.

* 클래스가 나타내고 있는 데이터에 다른 것을 추가할 수 있다. Ex) 간단한 문자열 클래스가 있다면 문자열을 출력할 때 사용할 색상을 나타내는 데이터 멤버가 추가된 클래스를 파생시킬 수 있다.

* 클래스 메서드가 동작하는 방식을 변경할 수 있다. Ex) 비행기 승객에게 제공되는 서비스를 나타내는 passenger 클래스가 있다면 고급 서비스를 제공하는 FirstClassPassenger 클래스를 파생시킬 수 있다.


## 13.1 간단한 기초 클래스로부터 시작하자

어떤 클래스를 다른 클래스로부터 상속하려할 때 오리지널 클래스를 기초 클래스, 상속받는 클래스를 파생 클래스라고 한다.

다음 Webtown Social Club은 탁구 동호회의 회원 정보를 관리하기로 결정했다.

```cpp
//tabtenn0.h -- 탁구 기초 클래스
#ifndef TABTEEN0_H_
#define TABTEEN0_H_
#include <string>

using std::string;
// 간단한 기초 클래스
class TableTennisPlayer
{
private:
    string firstname;
    string lastname;
    bool hasTable;
public:
        TableTennisPlayer(const string & fn = "none",
                          const string & ln = "none", bool ht = false);
        void Name() const;
        bool HasTable() const { return hasTable; };
        void ResetTable(bool v) { hasTable = v; };
};
#endif
```

```cpp
//tabtenn0.cpp -- 탁구 기초 클래스
#include "tabtenn0.h"
#include <iostream>

TableTennisPlayer::TableTennisPlayer (const string & fn,
    const string & ln, bool ht) : firstname(fn),
            lastname(ln), hasTable(ht) {}

void TableTennisPlayer::Name() const
{
        std::cout << lastname << ", " << firstname;
}
```

위 클래스가 하는 일은 선수의 이름과 그 선수가 탁구대를 소유하고 있는지 추적하는 것이다.

클래스는 이름을 소유하기 위해 표준 String 클래스를 사용한다. (문자열을 사용하는 것보다 편리하고 탄력적이며 안전하기 때문)

생성자는 초기자 리스트 구문을 사용한다.

```cpp
TableTennisPlayer::TableTennisPlayer (const string & fn,
    const string & ln, bool ht) : firstname(fn),
            lastname(ln), hasTable(ht) {}
```

다음은 클래스가 어떻게 동작하는지를 보여준다.

```cpp
// usett0.cpp -- 기초 클래스를 사용한다
#include <iostream>
#include "tabtenn0.h"

int main()
{
    using std::cout;
    TableTennisPlayer player1("Chuck", "Blizzard", true);
    TableTennisPlayer player2("Tara", "Boomdea", false);
    player1.Name();
    if (player1.HasTable())
        cout << ": 탁구대가 있다.\n";
    else
        cout << ": 탁구대가 없다.\n";
    player2.Name();
    if (player2.HasTable())
        cout << ": 탁구대가 있다.\n";
    else
        cout << ": 탁구대가 없다.\n";
    
    return 0;
}
```

### 클래스 파생시키기

TableTennisPlayer로 부터 원하는 클래스를 파생시킬 수 있다.

```cpp
// RatedPlayer는 TableTennisPlayer 기초 클래스로부터 파생된다.
class RatedPlayer : public TableTennisPlayer
{
...
};
```

콜론은 RatedPlayer 클래스가 TableTennisPlayer 클래스의 기초를 두고 있다는 것을 나타내고, TableTennisPlayer가 public 기초 클래스라는 것을 나타낸다.

이를 public 파생이라 한다. public 파생에서는 기초 클래스의 public 멤버들이 파생 클래스의 public 멤버가 된다. 기초 클래스의 private 부분들도 파생클래스의 일부가 된다.

RatedPlayer 객체를 선언한다면, 그 객체는 다음과 같은 특별한 속성을 가진다.

* 파생 클래스형의 객체 안에는 기초 클래스형의 데이터 멤버들이 저장된다. (파생 클래스는 기초 클래스의 구현들을 상속받는다.)

* 파생 클래스형의 객체는 기초 클래스형의 메서드들을 사용할 수 있다. (파생 클래스는 기초 클래스의 인터페이스를 상속받는다.)

이와 같은 상속받은 기능에 무엇을 추가할 필요가 있을까?

* 파생 클래스는 자기 자신의 생성자를 필요로 한다.

* 파생 클래스는 부가적인 데이터 멤버들과 멤버 함수들을 필요한 만큼 추가할 수 있다.

RatePlayer 파생 클래스에 탁구 대회에서 거둔 랭킹을 저장해보자

이는 하나의 데이터 멤버, 랭킹을 알아내는 메서드, 랭킹을 다시 설정하는 메서드가 필요하다.

```cpp
// 간단한 파생 클래스
class RatedPlayer : public TableTennisPlayer
{
private:
  unsigned int rating;  // 추가 데이터 멤버
public:
    RatedPlayer(unsigned int r = 0, const char * fn = "none",
            const string & ln = "none", bool ht = false);
    RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
    unsigned int Rating() { return rating; } // 추가 메서드
    void ResetRating(unsigned int r) { rating = r; } // 추가 메서드
};
```

생성자들은 새로 추가된 데이터 멤버와 상속받은 데이터 멤버들에 데이터를 제공해야 한다

첫 번째 RatedPlayer 생성자는 각각의 데이터 멤버들에 대해서 개별적인 형식 매개변수를 사용한다.

두 번째 RatedPlayer 생성자는 하나의 TableTennisPlayer 매개변수를 사용한다.

그 매개변수는 세 개의 항목을 하나의 묶음으로 결합한다.


### 생성자: 접근에 대하여

파생 클래스는 기초 클래스의 private 멤버에 직접 접근할 수 없다. 기초 클래스의 메서드들을 통해서 접근해야 한다.

Ex) RatedPlayer 생성자는 상속받은 멤버들을 직접 설정할 수 없다.

프로그램이 파생 클래스의 객체를 생성할 때 먼저, 기초 클래스의 객체를 생성한다.

Ex) 첫 번째 RatedPlayer 생성자의 코드는 다음과 같다.

```cpp
RatedPlayer::RatedPlayer(unsigned int r = 0, const char * fn,
  const string & ln, bool ht = false) : TableTennisPlayer(fn, ln, ht)
{
  rating = r;
}
```

```cpp
: TableTennisPlayer(fn, ln, ht)
```

이 부분이 멤버 초기자 리스트이다. 이때 TableTennisPlayer 생성자를 호출하게 된다.

> 멤버 초기자 리스트 문법
> Classy가 클래스이고 mem1,mem2,mem3가 클래스 데이터 멤버라면, 클래스 생성자는 다음과 같은 문법을 사용하여 그 데이터 멤버들 초기화 가능
> Classy::Classy(int n,int m):mem1(n),mem2(0),mem3(n*m+2)

```cpp
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
```

이 RatedPlayer 생성자는 실제 매개변수인 "Mallory", "Duck", true를 형식 매개변수인 fn, ln, ht에 대입한다. 그 후 형식 매개변수들을 실제 매개변수 자격으로 TableTennisPlayer 생성자에 전달한다. 

이제 RatedPlayer 생성자의 몸체 안으로 들어가 RatedPlayer 객체의 생성을 완수한다. 그 후 매개변수 r의 값을 rating 멤버에 대입한다.

만일 멤버 초기자 리스트를 생략한다면 디폴트 기초 클래스 생성자를 사용한다.

  두 번째 RatedPlayer 생성자의 코드는 다음과 같다.

```cpp
RatedPlayer::RatedPlayer(unsigned int r = 0, const TableTennis & tp)
  : TableTennisPlayer(tp)
{
  rating = r;
}
```

마찬가지로, TableTennisPlayer 정보가 TableTennisPlayer 생성자에 전달된다.

```cpp
TableTennisPlayer(tp)
```

tp는 const TableTennisPlayer &형이기 때문에 이 호출은 기초 클래스의 복사 생성자를 호출한다.

그러나 기초 클래스에 복사 생성자가 정의되어 있지 않아 복사 생성자를 컴파일러가 자동으로 생성한다.

> C++에서 복사 생성자란 자신과 같은 클래스 타입의 다른 객체에 대한 참조(reference)를 인수로 전달받아, 그 참조를 가지고 자신을 초기화하는 방법이다.

파생 클래스 생성자의 요점은 다음과 같다.

* 기초 클래스 객체가 먼저 생성된다.

* 파생 클래스 생성자가 멤버 초기자 리스트를 통해 기초 클래스 생성자에 기초 클래스 정보를 제공해야 한다.

* 파생 클래스 생성자는 파생 클래스에 추가된 데이터 멤버들을 초기화해야 한다.

### 파생 클래스 사용하기

파생 클래스를 사용하려면 프로그램이 기초 클래스 선언에 접근할 수 있어야 한다.

다음은 두 클래스 선언을 하나의 헤더 파일에 가지고 있다. 각각의 클래스를 별개의 헤더 파일에 넣을 수 있지만 두 클래스가 서로 연계되어 있기 때문에 함께 묶어 두는 것이 더 체계적이다.

```cpp
//tabtenn0.h -- 탁구 기초 클래스
#ifndef TABTEEN0_H_
#define TABTEEN0_H_
#include <string>

using std::string;
// 간단한 기초 클래스
class TableTennisPlayer
{
private:
    string firstname;
    string lastname;
    bool hasTable;
public:
        TableTennisPlayer(const string & fn = "none",
                          const string & ln = "none", bool ht = false);
        void Name() const;
        bool HasTable() const { return hasTable; };
        void ResetTable(bool v) { hasTable = v; };
};

// 간단한 파생 클래스
class RatedPlayer : public TableTennisPlayer
{
private:
  unsigned int rating;  // 추가 데이터 멤버
public:
    RatedPlayer(unsigned int r = 0, const char * fn = "none",
            const string & ln = "none", bool ht = false);
    RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
    unsigned int Rating() { return rating; } // 추가 메서드
    void ResetRating(unsigned int r) { rating = r; } // 추가 메서드
};

#endif
```

메서드 정의도 마찬가지로 묶어 두는 것이 체계적이다.

```cpp
//tabtenn0.cpp -- 탁구 기초 클래스
#include "tabtenn0.h"
#include <iostream>

TableTennisPlayer::TableTennisPlayer (const string & fn,
    const string & ln, bool ht) : firstname(fn),
            lastname(ln), hasTable(ht) {}

void TableTennisPlayer::Name() const
{
        std::cout << lastname << ", " << firstname;
}

// RatedPlayer 메서드
RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
    const string & ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
    rating = r;
}

RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
    : TableTennisPlayer(tp), rating(r)
{
}
```

다음은 TableTennisPlayer 클래스의 객체와 RatedPlayer 클래스의 객체를 생성한다.

두 클래스의 객체들이 TableTennisPlayer 클래스의 Name()과 HasTable() 메서드를 사용할 수 있다.

```cpp
// usett0.cpp -- 기초 클래스를 사용한다
#include <iostream>
#include "tabtenn0.h"

int main()
{
    using std::cout;
    using std::endl;
    TableTennisPlayer player1("Tara", "Boomdea", false);
    RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    rplayer1.Name();
    if (rplayer1.HasTable())
        cout << ": 탁구대가 있다.\n";
    else
        cout << ": 탁구대가 없다.\n";
    player1.Name();
    if (player1.HasTable())
        cout << ": 탁구대가 있다.\n";
    else
        cout << ": 탁구대가 없다.\n";
    cout << "이름: ";
    rplayer1.Name();
    cout << "; 랭킹: " << rplayer1.Rating() << endl;
// TableTennisPlayer 객체를 사용하여 RatedPlayer를 초기화한다.
    RatedPlayer rplayer2(1212, player1);
    cout << "이름: ";
    rplayer2.Name();
    cout << "; 랭킹: " << rplayer2.Rating() << endl;
    
    return 0;
}
```

### 파생 클래스와 기초 클래스의 특별한 관계

1. 파생 클래스 객체는 기초 클래스 메서드들이 private이 아니면 그것들을 사용할 수 있다.

  ```cpp
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  rpalyer1.Name();
  ```

2. 기초 클래스 포인터는 명시적 데이터형 변환 없이도 파생 클래스 객체를 지시할 수 있다.

3. 기초 클래스 참조는 명시적 데이터형 변환 없이도 파생 클래스 객체를 참조할 수 있다.

  ```cpp
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  TableTennisPlayer & rt = rplayer1;
  TableTennisPlayer * pt = &rpalyer1;
  rt.Name();  // 참조를 사용해 Name()을 호출한다
  pt->Name(); // 포인터를 사용하여 Name()을 호출한다
  ```

  그러나 기초 클래스 포인터나 참조는 기초 클래스 매서드에서만 호출할 수 있다.

  일반적으로 참조형과 포인터형이 대입되는 데이터형과 일치할 것을 요구한다. 그러나 상속의 경우 이 규칙이 완화된다

  하지만 이러한 규칙 완화는 일반통행적으로 파생 클래스의 참조와 포인터에 기초 클래스의 객체와 주소 대입을 할 수 없다.

기초 클래스 참조와 포인터가 파생 클래스 객체를 참조할 수 있다는 것은 다음과 같은 결과를 가져온다.

기초 클래스 참조와 포인터를 매개변수로 사용하는 함수는 기초 클래스 객체에도 사용할 수 있고 파생 클래스 객체에도 사용할 수 있다.

  ```cpp
  void Show(const TableTennisPlayer & rt)
  {
    using std::cout;
    cout << "이름: ";
    rt.Name();
    cout << "\n탁구대: ";
    if (rt.HasTable())
      cout << "있다.\n";
    else
      cout << "없다.\n";
  }
  ```

  형식 매개변수 rt는 기초 클래스에 대한 참조이다. 따라서 Show() 함수는 TableTennisPlayer 매개변수도 사용할 수 있고, RatedPlayer 매개변수도 사용할 수 있다.

  ```cpp
  TableTennisPlayer player1("Tara", "Boondea", false);
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  Show(player1);
  Show(rplayer1);
  ```

## 13.2 상속: is-a 관계

C++는 상속의 3가지 형식으로 public, protected, private를 가지고 있다.

public 상속이 가장 일반적인 형식이며 is-a 관계를 나타낸다. (파생 클래스 객체가 기초 클래스 객체이기도 하다는 뜻, is-a-kind-of로 표시하는 것이 더 정확하겠지만 is-a 관계로 흔히 사용)

기초 클래스 객체를 대상으로 수행할 수 있는 모든 작업을 파생 클래스 객체에서도 수행할 수 있다.

public 상속은 has-a, is-like-a, use-a 관계를 나타내지 않는다.


## 13.3 public 다형 상속

처한 상황에 따라 메서드가 여러 가지 다른 행동을 할 수 있기 때문에 여러 가지 형식을 가지고 있다는 의미에서 그런 행동을 다형이라 부른다.

public 다형 상속을 구현하는 두 가지 중요한 방법이 있다.

* 기초 클래스 메서드를 파생 클래스에서 다시 정의한다.

* 가상 메서드를 사용한다.

Ex) Brass Account 클래스(기본 당좌 구좌)에서 데이터는

* 고객 이름

* 계좌 번호

* 현재 잔액

메서드는

* 계좌를 개설한다

* 계좌에 돈을 입금한다.

* 계좌에서 돈을 인출한다.

* 계좌 정보를 출력한다.

Brass Plus Account 클래스(우대 당좌 구좌)에는 다음과 같은 정보를 추가하려 한다.

* 당좌 대월의 한도

* 당좌 대월의 이자율

* 상환할 원리금

돈을 인출하는 연산이 Brass Plus Account에 대한 당좌 대월을 처리할 수 있어야 한고, Brass Plus Account가 요구하는 부가적인 정보를 출력 연산이 보여주어야 한다.

```cpp
// brass.h -- 은행 당좌 클래스
#ifndef BRASS_H_
#define BRASS_H_
#include <string>
// Brass Account Class
class Brass
{
private:
    std::string fullName;
    long acctNum;
    double balance;
public:
    Brass(const std::string & s = "Nullbody", long an = -1, double bal = 0.0);
    void Deposit(double amt);
    virtual void Withdraw(double amt);
    double Balance() const;
    virtual void ViewAcct() const;
    virtual ~Brass() {}
};

//Brass Plus Account Class
class BrassPlus : public Brass
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string & s = "Nullbody", long an = -1, double bal = 0.0, double ml = 500, double r = 0.11125);
    BrassPlus(const Brass & ba, double ml = 500, double r = 0.11125);
    virtual void ViewAcct() const;
    virtual void Withdraw(double amt);
    void ResetMax(double m) { maxLoan = m; }
    void ResetRate(double r) { rate = r; }
    void ResetOwes() { owesBank = 0; }
};

#endif
```

다음과 같은 몇 가지 사항에 주목하자

* BrassPlus 클래스는 Brass 클래스에 기초를 두고 3개의 새로운 private 데이터 멤버와 3개의 public 멤버 함수를 추가하였다.

* Brass 클래스와 BrassPlus 클래스 둘 다 ViewAcct()와 Withdraw() 메서드를 선언하고 있다. 하지만 각 객체에 대해 하는 행동이 다른 메서드들이다.

* Brass 클래스는 virtual이라는 새로운 키워드를 사용해 메서드를 선언하고 있는데 이러한 메서들을 가상 메서드라고 부른다.

* Brass 클래스는 아무일도 하지 않지만 가상 파괴자를 선언하고 있다.

#### 클래스의 구현

```cpp
// brass.cpp -- 은행 당좌 클래스의 메서드들
#include <iostream>
#include "brass.h"
using std::cout;
using std::endl;
using std::string;

// 포맷팅 관현
typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore (format f, precis p);

// Brass 메서드들

Brass::Brass(const string & s, long an, double bal)
{
    fullName = s;
    acctNum = an;
    balance = bal;
}

void Brass::Deposit(double amt)
{
    if (amt < 0)
        cout << "마이너스 입금은 허용되지 않습니다.\n"
             << "그래서 입금이 취소되었습니다.\n";
    else
        balance += amt;
}

void Brass::Withdraw(double amt)
{
    // ###.## 형식으로 설정한다
    format initialState = setFormat();
    precis prec = cout.precision(2);
    
    if (amt < 0)
        cout << "마이너스 입금은 허용되지 않습니다.\n"
             << "그래서 입금이 취소되었습니다.\n";
    else if (amt <= balance)
        balance -= amt;
    else
        cout << "인출을 요구한 금액 $" << amt
             << "가 현재 잔액을 초과합니다.\n"
             << "그래서 인출이 취소되었습니다";
    restore(initialState, prec);
}
double Brass::Balance() const
{
    return balance;
}

void Brass::ViewAcct() const
{
    // ###.## 형식으로 설정한다.
    format initialState = setFormat();
    precis prec = cout.precision(2);
        cout << "고객 이름: " << fullName << endl;
        cout << "계좌 번호: " << acctNum << endl;
        cout << "현재 잔액: " << balance << endl;
    restore(initialState, prec);
}

// BrassPlus 메서드들
BrassPlus::BrassPlus(const string & s, long an, double bal, double ml, double r) : Brass(s, an, bal)
{
    maxLoan = ml;
    owesBank = 0.0;
    rate = r;
}

BrassPlus::BrassPlus(const Brass & ba, double ml, double r) : Brass(ba)
{
    maxLoan = ml;
    owesBank = 0.0;
    rate = r;
}

void BrassPlus::ViewAcct() const
{
    // ###.## 형식으로 설정한다.
    format initialState = setFormat();
    precis prec = cout.precision(2);
    
    Brass::ViewAcct();  // 기초 부분을 출력
    cout << "당좌 대월 한도액: $" << maxLoan << endl;
    cout << "상환할 원리금: $" << owesBank << endl;
    cout.precision(3);
    cout << "당좌 대월 이자율: " << 100 * rate << "%\n";
    restore(initialState, prec);
}

void BrassPlus::Withdraw(double amt)
{
    // ###.## 형식으로 설정한다
    format initialState = setFormat();
    precis prec = cout.precision(2);
    
    double bal = Balance();
    if (amt < 0)
        Brass::Withdraw(amt);
    else if (amt <= bal + maxLoan - owesBank)
    {
        double advance = amt - bal;
        owesBank += advance * (1.0 + rate);
        cout << "당좌 대월 금액: $" << advance << endl;
        cout << "당좌 대월 이자: $" << advance * rate << endl;
        Deposit(advance);
        Brass::Withdraw(amt);
    }
    else
            cout << "당좌 대월 한도가 초과되어 거래가 취소 되었습니다.\n";
        restore(initialState, prec);
}

format setFormat()
{
    return cout.setf(std::ios_base::fixed,
                    std::ios_base::floatfield);
}

void restore(format f, precis p)
{
    cout.setf(f,std::ios_base::floatfield);
    cout.precision(p);
}
```

ViewAcct()와 Withdraw()를 다시 정의해 다형 상속을 한다.

#### Brass와 BrassPlus 클래스의 사용

```cpp
// usebrass1.cpp -- 은행 당좌 클래스를 테스트한다
// brass.cpp와 함께 컴파일한다.
#include <iostream>
#include "brass.h"

int main()
{
    using std::cout;
    using std::endl;
    
    Brass Piggy("porcelot Pigg", 381299, 4000.00);
    BrassPlus Hoggy("Horatio Hogg", 382288, 3000.00);
    Piggy.ViewAcct();
    cout << endl;
    Hoggy.ViewAcct();
    cout << endl;
    cout << "Hogg 씨의 계좌에 $1000 입금:\n";
    Hoggy.Deposit(1000.00);
    cout << "Hogg 씨의 현재 잔액: $" << Hoggy.Balance() << endl;
    cout << "Pigg 씨의 계좌에서 $4200 인출:\n";
    Piggy.Withdraw(4200.00);
    cout << "Pigg 씨의 현재 잔액: $" << Piggy.Balance() << endl;
    cout << "Hogg 씨의 계좌에서 $4200 인출:\n";
    Hoggy.Withdraw(4200.00);
    Hoggy.ViewAcct();
    
    return 0;
}
```


#### 가상 메서드의 행동

Brass와 BrassPlus 객체들의 혼합을 하나의 배열에 저장하여 관리하면 편리할 것이다.

하지만 배열에 들어갈 항목을의 데이터형이 같이 않으면 불가능하다.

그러나 Brass를 지시하는 포인터들의 배열을 만들면 Brass를 지시하는 포인터가 Brass 객체와 BrassPlus 객체를 모두 지시할 수 있으므로 객체형이 하나 이상인 객체들의 집합을 하나의 배열로 나타내는 방법이다.

이는 다형이다.

