---
layout: single
title:  "2023 C++ 학습하기"
categories: coding
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


# C++







---





## 01장 C++ 첫걸음



01장에서는 C++의 탄생 배경을 살펴보고 C++ 프로그램을 작성할 때 지켜야할 몇가지 규칙을 알아보자.





### 01.1 C++를 배우자



C++는

>C의 절자적 언어



>C에 클래스를 추가하여 실현하는 C++의 객체 지향 언어 방식



>C++의 템플릿이 지원하는 일반화 프로그래밍 방식



이 세 가지 프로그래밍 방식을 하나로 결합한다.



C++를 사용하는 주된 이유는 객체 지향 프로그래밍을 할 수 있기 때문이므로 C의 기초사항을 잘 알아야 한다. 그 이유는 기본적인 데이터형과 연산자, 제어 구조, 구문 규칙을 C 언어가 제공하기 때문이다.





### 01.2 C++의 탄생



>점점 기능이 강력해진 컴퓨터는 더 크고 더 복잡한 프로그램을 요구



>1970년대에 C나 Pascal과 같은 컴퓨터 언어들이 등장며 이 문제의 해결책을 제시해 구조적 프로그래밍의 시대를 열음



>C 언어는 구조적 프로그래밍을 위한 도구를 제공하며, 통신 포트나 디스크 드라이브와 같은 하드웨어까지 직접 제어할 수 있었고, 크기가 작으면서도 실행 속도가 빠른 프로그램을 작성할수 있었기에 1980년대에 가장 인기 있는 프로그래밍이 됨.





* C언어



  1970년대 초반에 벨 연구소에서는 Unix라는 운영체제를 개발하고 있었는데 이 과정에서 저수준의 언어의 효율성과 하드웨어 접근 능력, 고수준 언어의 일반성과 이식성이 결합된 프로그래밍 언어가 필요했고 이 때 C가 만들어졌다.





* C의 프로그래밍 철학



  일반적으로 컴퓨터 언어는 '데이터'와 '알고리즘' 두 개념을 다룬다.

  >'데이터'는 프로그램이 사용하고 처리하는 정보



  >'알고리즘'은 프로그램이 데이터를 처리하는 방법



  C는 데이터보다 알고리즘에 더 치중한 절차적언어이다. 컴퓨터가 수행해야 할 동작들을 명확히 구분하고, 그 구분된 동작들을 프로그래밍 언어로 구현하는 것이다.



  ex) for 루프, while 루프, do while 루프 if else 구문 등 정형화 된 조건을 통해 분기를 사용하도록 제한.



  하향식 설계 또한 구조적 프로그래밍의 하나의 철학이다.





* C++의 등장: 객체 지향 프로그래밍



  구조적 프로그래밍 철학이 프로그램의 간결성과 신뢰성, 유지 보수의 용이설에 많은 향상을 가져왔지만 규모가 큰 프로그래밍에는 여전히 어려웠다.



  이 해결책으로 객체 지향 프로그래밍 철학이 등장하였다.

  해결해야 할 문제를 절차적 접근 방식에 억지로 끼워 맞추지 않고 언어 자체를 해결해야 할 문제에 맞춘다. 즉, 해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계를 한다.

  C++에서는 클래스가 그와 같은 목적으로 설계되는 새로은 데이터형이고, 객체는 그러한 클래스에 의해 만들어지는 특정한 데이터 구조이다.





* C++와 일반화 프로그래밍



  일반화 프로그래밍과 OOP는 소스코드의 손쉬운 재활용이라는 목표와, 포괄 개념의 추상화 기술을 서로 공유한다.



  > OPP는 데이터 측면을 강조

  

  > 일반화 프로그래밍은 알고리즘 측면을 강조





* C++의 기원



  C++은 C와 마찬가지로 벨 연구소에서 개발되었다.

  C++ 개발의 주 목적은 "프로그래머들이 보다 쉽고 즐겁게 유용한 프로그래밍을 작성 할 수 있도록 하는 것" 이었다.


### 01.3 이식성과 표준



프로그램이 이식성을 갖기 위해서는 아래의 두 가지 장애 요인이 있다.



1. 하드웨어

  특정 하드웨어에 종속적인 프로그램은 이식성을 갖지 못한다.

3. 프로그래밍 언어 간의 상이성

  여러 버전의 C++중에 C++98을 표준으로 정했다.







### 01.4 프로그램 작성 요령



1. 손에 익은 텍스트 에디터를 사용하여 프로그램을 작성하고 파일로 저장. (이 파일이 프로그램의 소스 코드)



2. 소스 코드를 컴파일한다. (번역 된 파일이 목적 코드)



3. 목적코드에 부가적인 코드를 링크시킨다.



* 소스 코드 파일 작성



  소스코드의 파일 이름을 생성할 때에는 그 언어의 소스 코드라는 것을 나타내기 위해 반드시 접미어를 붙여야 한다. 이를 확장자라고 한다.



  확장자는 어떤 컴파일러를 사용하느냐에 따라 달라진다.


## 02장 C++시작하기


### 02.1 C++의 시작



> '//' 는 주석이다.



> 대문자와 소문자를 구별한다.



> 이 책에서는 확장자로 cpp를 사용한다.



```cpp
#include <iostream>
int main()
{
    using namespace std;
    cout << "C++의 세계로 오십시오.";
    cout << endl;
    cout << "후회하지 않으실 겁니다!" << endl;
    return 0;
}
```

위 코드는 다음과 같은 구성 요소들을 가진다.

> //로 시작되는 주석문

> #include 전처리 지시자

> 함수 머리: int main()

> using namespace 지시자

> '{'와 '}'로 범위가 정해지는 함수 몸체

> C++의 cout 기능을 사용하여 메세지를 출력하는 구문들

> main() 함수를 종료하는 return 구문

* main()함수

  
  기본구조는 다음과 같다.
  
```cpp
int main()
{
    구문들
    return 0;
}
```

>int main() 함수가 자신을 호출한 함수로부터 어떠한 정보도 전달받지 않지만('()'안이 비어있음), 그 함수에게 정수값을 리턴한다는것(int).


* C++ 주석문

  주석문은 프로그래머가 프로그램 안에 기록해 두는 일종의 메모로, 프로그램의 구역을 구분하거나 코드의 어떤부분이 무슨 역할을 하는 것인지 표시하는 데 사용한다.

* C++ 전처리기와 iostream 파일

  C++의 일반적인 입출력 기능을 사용하려면 다음 두행을 프로그램에 꼭 넣어야 한다.

```cpp
#include <iostream>  // 전처리 지시자

using namespace std;
```

이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다. 이와 같이 컴파일되기 전에 소스코드에 텍스트를 추가하거나 텍스트를 대체하는 것이 전처리기가 수행하는 기본적인 역할이다.

iostream의 i는 프로그램안으로 들어오는 정보(입력), o는 프로그램이 바깥으로 내보내는 정보(출력)를 나타낸다. cout 기능을 사용하려면 이러한 정의가 필요하다.

* 헤더 파일 이름

iostream과 같은 파일을 포함파일 또는 헤더 파일이라고 부른다.

C++에서는 이름 짓는 규칙이 바뀌었는데 C의 헤더 파일의 이름에서 '.h'를 뺀 것이다.

|헤더 파일의 종류|규칙|보기|설명|
|---|---|---|---|
|C++ 구식 스타일| .h로 끝남| iostream.h| C++ 프로그램에서 사용할 수 있다.|
|C 구식 스타일| .h로 끝남| math.h| C와 C++ 프로그램에 모두 사용할 수 있다.|
|C++ 최신 스타일| 확장자 없음| iostream| C++ 프로그램에서 사용할 수 있고, namespace std를 사용한다.|
|C 변환 스타일| C 접두어, 확장자 없음| cmath| C++ 프로그램에서 사용할 수 있고, namespace std와 같이 C에 없는 기능은 사용할 수도 있고 못할 수도 있다.|

* 이름 공간

  iostream.h 대신에 iostream을 사용할 때 프로그램이 iostraem의 정의를 사용할 수 있게 하려면 'using namespace std;' 이름 공간 지시자를 사용해야한다.
이것을 using 지시자라고 한다.

* cout을 이용한 C++의 출력

```cpp
cout << "C++의 세계로 오십시오.";
```
> 큰따옴표 안에 들어 있는 부분이 출력할 메세지이다. C++에서 이 연속된 문자들을 문자열이라고 부른다.

> << 표시는 구문이 그 문자열을 cout에 전달한다는 것을 뜻한다.

> cout은 문자열, 수, 문자 들을 포함한 여러가지 다양한 정보들을 출력하는 방법을 알고 있는, 미리 정의된 객체이다.

* 조정자 endl

```cpp
cout << endl;
```

  endl은 새로운 행이 시작된다는 중요한 개념을 나타내는 특별한 C++표기이다.
  
  cout은 문자열을 출력하고 다음 행의 시작 위치로 커서를 자동으로 넘겨주지 않기에 endl을 통해 줄바꿈을 해주어야 한다.

* 개행 문자(\n)

```cpp
cout << "다음은 뭔데?\n";    // \n은 새로운 행을 시작하라는 의미
```

  기본적으로 cout << endl;와 cout << "\n"은 같은 기능을 한다.

* C++ 소스 코드의 모양

  C++은 세미콜론으로 구문의 끝을 표시하므로 하나의 구문을 여러 행에 펼칠 수도 있고 여러개의 구문을 한 행에 놓을 수도 있다.

  하지만 이름과 문자열 중간에는 빈칸이나 캐리지 리턴을 넣을 수는 없다.

* 토큰과 화이트 스페이스

  한 행의 코드에서 더 이상 분리할 수 없는 기본 요소를 토큰이라 한다.

  일반적으로 하나의 토큰은 빈칸, 탭, 캐리지 리턴에 의하여 다음 토큰과 분리되는데 이들을 집합적으로 화이트 스페이스라고 한다.

* C++ 소스 코드 스타일

> 한행에 하나의 구문을 사용한다.
>
> 함수를 여는 중괄호'{'와 닫는 중괄호 '}'에 각각 한행을 할애한다.
>
> 함수 안에 들어갈 구문들은 중괄호에서 약간 오른쪽으로 들어간 위치에서 시작한다.
>
> 함수 이름과 괄호 사이에는 어떠한 화이트스페이스도 넣지 않는다.

### 02.2 C++구문

```cpp
// carrots.cpp
// 하나의 변수를 사용하고 출력한다.

#include <iostream>

int main()
{
  using namespace std;

  int carrots;    // 정수 변수를 선언

  carrots = 25;    //변수에 값을 대입
  cout << "나는 당근을 ";
  cout << carrots;
  cout << "개 가지고 있다.";
  cout << endl;
  carrots = carrots-1;
  cout << "아삭아삭, 이제 당근은 " << carrots << "개이다." << endl;
  return 0;
}
```

실행 결과는
```
나는 당근을 25개 가지고 있다.
아삭아삭, 이제 당근은 24개이다.
```

변수를 선언 하는 선언 구문, 변수에 값을 대입하는 대입 구문이 추가 되었다.

* 선언 구문과 변수

```cpp
int carrots;
```

  하나의 정수를 저장할 수 있는 기억 공간을 프로그램이 사용할 예정이라고 선언한다.
  
  그러면 컴파일러는 이를 위한 기억공간을 대입하고 그 위치가 어디인지 말해 주는 꼬리표를 붙이는 작업을 수행한다.

  다음으로 해야할 일은 저장된 데이터의 이름을 선언하는 것이다. 기억 공간에 저장되어 있는 값을 carrots이라는 이름으로 사용하겠다는 것이다.
  
  carrots와 같은 역할을 하는 것을 변수라고 부른다.

* 대입 구문

  대입 구문은 기억 위치에 어떤 값을 대입한다.

```cpp
carrots = 25;    // 변수 carrots로 나타내는 기억 위치에 정수 25를 대입
```

여기서 등호는 대입 연산자라고 부른다. 대입 연산자를 연이어 사용할 수도 있다.

```cpp
int steinway;
int baldwin;
int yamaha;
yamaha = baldwin = steinway = 88;
```

위 대입 구문은 오른쪽에서 왼쪽으로 차례대로 처리된다.

* cout의 새로운 사용법

  지금까지 cout에 출력한 문자열을 넘겨주었지만 정수값을 가지고 있는 변수를 cout에 넘겨줄 수도 있다.

```cpp
cout << carrots;
```

carrots 이라는 단어를 출력하지 않고 변수 carrots에 저장되어 있는 정수값인 25를 출력한다.

cout은 내부적으로 carrots를 정수 25로 대체하고 적당한 출략 믄지 '2'와 '5'로 변환하는 작업을 한다. (cout이 int형의 수를 출력하기 전에 문자형으로 변환한다.)

### 02.3 C++의 기타 구문

cout은 출력을 수행하는 객체인데 반하여 cin은 입력을 수행하는 객체이다.

```cpp
//getinfo.cpp -- 입력과 출력
#include <iostream>

int main()
{
  using namespace std;

  int carrots;

  cout << "당근을 몇개나 가지고 있니?" << endl;
  cin >> carrots;    // C++ 입력
  cout << "여기 두 개가 더 있다. ";
  carrots = carrots + 2;
// 다음 라인은 출력을 연결한다.
  cout << "이제 당근은 모두 " << carrots << "개이다." << endl;
  return 0;
}
```

실행 결과는 다음과 같다.

```
당근을 몇 개나 가지고 있니?
12
여기 두 개가 더 있다. 이제 당근은 모두 14개이다.
```

cin을 사용하여 키보드로부터 정수를 입력받았다.

*cin 사용법

```cpp
cin >> carrots
```

  cin은 '>>' 연산자를 사용하여 입력 스트림에서 문자들을 가져온다. 가져온 정보를 저장할 변수는 '>>' 연산자의 오른쪽에 적는다.

* count에 의한 출력의 결합

  iostream 파일에는 << 연산자가 다음과 같이 여러 개의 출력을 하나로 결합 할 수 있도록 정의되어 있다.

```cpp
cout << "이제 당근은 모두 " << carrots << "개이다." << endl;
```

* cin과 cout: 클래스 맛보기

  클래스는 사용자가 정의하는 데이터형이다. 클래스를 정의하려면, 클래스로 표현할 수 있는 정보의 종류는 무엇이고 그것으로 수행할 수 있는 동작이 무엇인지 서술해야한다.

### 02.4 함수

C++ 함수는 리턴값이 있는 함수, 리턴값이 없는 함수 두 가지 유형이 있다.

* 리턴값이 있는 함수

```cpp
x = sqrt(6.25);    // 값 2.5를 리턴하여 x에 대입
```

  sqrt(6.25) 라는 표현이 sqrt() 함수를 호출한다.

  C++은 함수 원형 구문을 사용하여 리턴 값의 정보를 컴파일러에게 전달해야한다.

  C++ 라이브러리에는 sqrt() 함수가 소수부가 있는 수를 매개변수로 전달받으며, 동일한 데이터형을 리턴한다고 정의 되어있다.

```cpp
double sqrt(double);    // 함수 원형
```

프로그램에서 sqrt() 함수를 사용하려면 함수 원형을 제공해야 하는데 이 방법에는 두가지가 있다.

> 함수 원형을 소스 코드 파일에 직접 입력한다.

> 함수 원형이 들어 있는 cmath(구식 시스템에서는 math.h) 헤더 파일을 포함시킨다.

함수 원형과 함수 정의는 다르다. 함수 원형은 함수에 전달하는 정보와 리턴하는 정보만 서술하는 반면 함수 정의는 수행할 작업을 위한 실제 코드를 포함한다.

함수 원형은 일반적으로 main() 함수 정의 앞에 둔다.

```cpp
#include <iostream>
#include <cmath>    // cmath 해더 파일을 포함시켜 함수 원형을 제공

int main()
{

  ...

}
```

* 변이 함수들

  어떤 함수는 하나 이상의 정보를 요구하는데 여러 개의 매개변수를 콤마로 분리한다.

```cpp
double pow(double, double);    // 2개의 매개변수를 가진 함수 원형
```

```cpp
answer = pow(5.0, 8.0);    // 5의 8제곱
```

  매개변수를 사용하지 않는 함수도 있다.

```cpp
int rand(void);    // C라이브러리의 함수. 임의의 정수 리턴
```

  값을 리턴하지 않는 함수도 있다.

```cpp
coid bucks(double);    // bucks ()는 값을 리턴하지 않으므로 대입 구문이나 다른 표현의 일부로 사용할 수 없고, 순수한 함수 호출 구문으로만 사용
```

* 사용자 정의 함수

  사용자가 직접 함수를 작성하는 것이 사용자 정의 함수이다. main() 함수도 사용자 정의함수이다.

```cpp
// ourfunc.cpp -- 사용자가 작성하는 함수를 정의한다.
#include <iostream>
void simon(int);    // simon()을 위한 함수 원형

int main()
{
  using namespace std;
  simon(3);    // simon() 함수를 호출
  cout << "정수를 하나 고르시오: ";
  int count
  cin >> count;
  simon(count);    // simin() 함수를 다시 호출
  cout << "끝!" << endl;
  return 0;
}

void simon(int n)    // simon() 함수를 정의
{
  using namespace std;
  cout << "simon 왈, 발가락을 " << n << "번 두두려라." << endl;
}    // void형 함수는 리턴값이 없기에 return 구문이 필요없다.
```

  main() 함수는 simon() 함수를 두 번 호출한다.


* 함수 모양

```cpp
type functionname(arugumentlsit)
{
  statements
}
```


* 함수 머리  

  simon() 함수는 다음과 같은 함수 머리를 가지고 있다.

```cpp
void simon(int n)    // void는 값을 리턴 하지 않는다는 것. int n은 하나의 int형 매개변수를 전달 받는다는 것.
```

  main() 함수의 머리

```cpp
int main()    // int는 int형 값을 리턴한다는 것. 괄호가 비어 있는 것은 매개변수가 없다는 것.
```


* 리턴값이 있는 사용자 정의 함수

  영국을 방문하는 사람의 체중 환산 프로그램

```cppp
// convert.cpp -- 스톤을 파운드로 환산한다
#include <iostream>
int stonetolb(int);    // 함수 원형
int main()
{
  using namespace std;
  int stone;
  cout << "체중을 스톤 단위로 입력하시오: ";
  cin >> stone;
  int pounds = stonetolb(stone);
  cout << stone << " 스톤은 ";
  cout << pounds << " 파운드입니다." << endl;
  return 0;
}

int stonetolb(int sts)
{
  return 14 * sts;
}
```

```
체중을 스톤 단위로 입력하시오: 15
15스톤은 210 파운드입니다.
```

  cin으로 변수 stone에 int형 값을 입력받고 stonetolb() 함수의 매개변수로 전달되어 변수 sts에 대입된다. 이때 stonetolb() 함수는 14 * sts 수식값을 계산하여 main() 함수로 리턴한다. 

* 복수 함수 프로그램에 using 지시자 넣기

  두 개의 함수가 각각의 using 지시자를 가지고 있는 경우가 있다.

  이는 두 함수가 모두 cout을 사용하고, std 이름 공간에 있는 cout 정의에 접근할 필요가 있기 때문이다.

  두 함수가 std 이름 공간을 사용할 수 있게 만드는 또 다른 방법은 두 함수의 외부 그리고 위에 using 지시자를 넣는 것이다.

  (ex. int main()함수와 void simon(int n)함수를 정의하기 전 그 위에 using namespace std; 를 넣는다.) 

  하지만 접근이 필요한 함수들만 차별적으로 std 이름 공간에 접근 할 수 있도록 제한하는 것이 유리하다.


## 03장 데이터 처리

C++에 내장된 데이터형에는 기본형과 복합형이 있다.  

기본형에는 정수를 표현할 수 있는 정수형과, 소수부가 있는 수를 표현할 수 있는 부동 소수점형이 있다.

이 두가지 데이터형으로 모든 프로그래밍 상황에 대처할 수 없기 때문에 필요에 따라 변형 데이터형이 만들어져 있다.

### 03.1 간단한 변수

컴퓨터에 정보를 저장하려면 프로그램은 다음과 같은 세가지를 알아야 한다.

> 어디에 저장되는가?

> 어떤 값이 저장되는가?

> 어떤 종류의 정보인가?

* 변수 이름

  C++에서 변수 이름을 지을 때는 다음과 같은 간단한 규칙을 따른다.

> 변수 이름에는 영문자, 숫자, 밑줄(_) 문자만 사용할 수 있다.

> 숫자를 변수 이름의 첫 문자로 사용할 수 없다.

> 변수 이름에서 대문자와 소문자는 구별된다.

> C++의 키워드는 변수 이름으로 사용할 수 없다.

> 두 개의 밑줄 문자로 시작하는 이름이나, 밑줄 문자와 대문자로 시작하는 이름은, 그것을 사용하는 컴파일러와 리소스가 사용하기로 예약되어 있다. 하나의 밑줄 문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가 전역 식별자로 사용하기로 예약되어 있다.

> 변수 이름의 길이는 제한이 없으며, 변수 이름에 쓰인 모든 문자들이 유효하다. 그러나 어떤 플랫폼은 고유의 길이 제한이 있다.


* 정수형

  정수는 소수부가 없는 수를 말한다.

  무한하게 많은 정수를 모두 표현할 수 없기에 컴퓨터 언어는 정수들의 부분집합만을 나타낸다.

  C++의 정수형들은 서로 다른 크기의 메모리를 사용하여 정수를 저장하는데,

  signed 데이터형은 양수값과 음수값을 모두 나타낼 수 있으나, unsigned 데이터형은 양수값만 나타낼 수 있다.

  기본 정수형의 크기 순서로 나열하면 char, short, int, long 그리고 C++11의 long long 순이다. 각각 signed형과 unsigned형이 따로 존재한다.

* short, int, long, long long 정수형

  각각 정수를 저장하는 데 사용하는 비트 수가 다르다.

  > short형은 최소한 16비트 폭을 가진다.
  
  > int형은 최소한 short만큼은 크다.

  > long형은 최소한 32비트 폭을 가지며 최소한 int만큼은 크다.
  
  > long long형은 최소한 64비트 폭을 가지며 최소한 long만큼은 크다.
  
  다른 데이터 형들의 변수도 int형 변수처럼 선언할 수 있다.

```cpp
short score;    // short형의 정수형 변수를 만든다
int temperature;    // int형의 정수형 변수를 만든다
long position;    // long형의 정수형 변수르 만든다
```

  여기서 short와 long은 각각 short int, long int를 줄인 것이다.

  C++ 시스템의 정수 크기 얼마인지 알고 싶으면, 데이터형의 크기를 알아내는 C++의 도구를 사용할 수 있다.

  > 첫 번째 방법: sizeof 연산자를 이용한다.

  > 두 번째 방법: 여러 가지 정수형들의 범위에 대한 정보가 들어 있는 climits 헤더 파일을 열어 본다.

    이 파일에는 여러 정수형들의 서로 다른 한계값을 기호 이름으로 정의하고 있다. 예들 들어, int형의 최대값을 INT_MAX로 char형의 비트 수를 CHAR_BIT로 정의하고 있다.

* 초기화

  초기화는 선언과 대입을 하나로 조합한다.

```cpp
int n_int = INT_MAX;
```

위와 같은 구문은 n_int를 int형 변수로 선언하고 그 변수에 int형의 최대값을 대입한다. 또는 255와 같은 상수를 사용할 수 있다.
