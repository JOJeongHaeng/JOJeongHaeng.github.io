---
layout: single
title:  "2023 C++ 학습하기 4차시"
categories: coding
author_profile: false
toc: true
toc_sticky: true
toc_depth: 2
---

<head>
  <style>   
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# 10장 객체와 클래스

객체 지향 프로그래밍(OOP)은 프로그램 설계 방법중 하나이다.

C++은 객체 지향 프로그래밍을 쉽게 구현할 수 있도록 만든 프로그래밍 언어이다.

다음은 OOP의 가장 중요한 기능들이다.

* 추상화(abstraction)

* 캡슐화(encapsulation)와 데이터 은닉(data hiding)

* 다형(polymorphism)

* 상속(inheritance)

* 코드의 재활용(reusability of code)

클래스는 이러한 기능들을 구현하고 결합하는 데 사용되는 가장 중요한 C++ 도구이다.

이 장에서는 클래스가 무엇인지 알아본 후 OOP의 기능들을 설명한다.

## 10.1 절차식 프로그래밍과 객체 지향 프로그래밍

절차적 접근 방식은 처리해야 할 절차에 초점을 맞추고 데이터를 표현할 방법을 찾는다.

OOP 접근 방식은 객체를 서술하는 데 필요한 데이터와, 사용자가 그 데이터를 다루는 방법에 대해서 생각하며 사용자가 이해하는 방식대로 객체에 초점을 맞춘다.

이러한 인터페이스를 설계한 후 인터페이스와 데이터 저장 형태을 구현한다.

## 10.2 추상화와 클래스

컴퓨터 분야에서 추상화란 정보를 사용자 인터페이스로 표현하는 것이다.

즉, 어떤 문제에 대해 필수적인 조작적 요인을 추상화하고 해결책을 표현하는 것이다.

클래스가 추상화 인터페이스를 구현하는 정의 데이터형이다.

### 데이터형이란 무엇인가?

데이터형은 메모리에 저장되는 형태 뿐만 아니라 그것을 대상으로 수행할 수 있는 연산에 의해 정의된다.

int형은 사칙연산, 나머지 연산자까지 사용 가능하지만 포인터는 int형에 적용할 수 있는 연산을 허용하지 않는다.

어떤 변수를 선언한다고 할 때 단지 메모리 대입이 아닌 그 데이터형이 수행할 수 있는 연산도 함께 정의 된다는 것이다.

쉽게 말해 기본형을 서술하는 것은 다음과 같은 세 가지를 결정하는 것이다.

* 데이터 객체에 필요한 메모리의 크기를 결정한다.

* 메모리에 있는 비트들을 어떻게 해석할 것인지 결정한다. (long 값과 float 값이 메모리에서 동일한 비트를 사용해도 서로 다른 수치 값으로 해석)

* 데이터 객체를 사용하여 수행할 수 있는 연산이나 메소드를 결정한다.

내장된 기본 데이터형은 동작에 관한 정보가 컴파일러에 내장된다.

그러나 사용자 정의 데이터형은 이와 같은 정보를 직접 제공해야 한다.

### C++의 클래스

클래스는 추상화를 사용자 정의 데이터형으로 변환해 주는 C++의 수단이다.

클래스는 데이터 표현현과 데이터를 조작하는 메서드들을 하나의 패키지 안에 결합한다.

EX) 주식을 나타내는 클래스를 생각해보자

한주를 기본단위로 삼고, 한 주를 표현하는 클래스를 정의하는 것이 주식을 나타내는 방법이라면 100주를 나타낼 때 100개의 객체가 필요하다.

이렇게 하지 않고 한 사람이 어떤 한 주식에 대해 가지고 있는 지분을 기본 단위로 표현할 수 있다.

이러면 소유한 주식의 수는 데이터 표현의 일부가 된다.

클래스 서술은 두 부분으로 이루어진다.

* 클래스 선언: 데이터 멤버와 public 인터페이스, (메서드라고 부르는) 멤버 함수를 이용하여 데이터 표현을 서술한다.

* 클래스 메서드 정의: 클래스 멤버 함수가 어떻게 구현되는지를 서술한다.

간단히 말하면 클래스 선언은 **클래스의 개요**를 제공, 메서드 정의는 **세부 사항**을 제공하는 것이다.

> ### 인터페이스란 무엇인가?
>
> 인터페이스는 두 시스템(ex. 컴퓨터와 프린터, 사용자와 컴퓨터 프로그램) 간의 상호 작용을 위한 공통된 프레임 워크다.
>
> 클래스와 관련해서는 public 인터페이스를 말하는데, public은 그 클래스를 사용하는 프로그램이다.
>
> 인터페이스는 그 클래스를 작성한 누군가가 제공한 메서드들로 구성되는데, 프로그래머가 클래스 객체와 상호 작용하는 코드를 작성할 수 있게 해 준다.
>
> 예를 들어 string 객체에 들어 있는 문자들의 개수는 클래스 작성자가 제공한 size() 메서드를 사용하면 된다.
>
> size() 메서드는 사용자와 string 클래스 객체 사이의 public 인터페이스의 일부이다.

전형적으로 C++11 프로그래머들은 인터페이스를 헤더 파일의 클래스 선언 안에 위치시키고 구현 부분은 소스 코드 파일의 클래스 함수들을 위한 코드 안에 위치시킨다.

다음은 이 전형적인 스타일의 Stock 클래스 선언이다.

```cpp
// stock00.h -- Stock 클래스 인터 페이스
// version 00
#ifndef STOCK00_H_
#define STOCK00_H_

#include <string>

class Stock    // 클래스 선언
{
private:
  std::string company;
  long shares;
  double share_val;
  double total_val;
  void set_tot() { total_val = shares * share_val; }
public:
  void acquire(const std::string % co, long n, double pr);
  void buy(long num, double price);
  void sell(long num, double price);
  void update(double price);
  void show();
};

#endif
```

C++ 키워드인 class는 위 코드가 클래스 설계를 위한 정의라는 사실을 나타낸다.

class가 포함된 이 구문은 Stock을 이 새로운 클래스의 데이터형 이름으로 만든다.

이 선언으로 Stock형의 변수인 객체나 인스턴스를 선언할 수 있게 된다.

```cpp
Stock sally;
Stock solly;
```

sally와 solly라는 두 개의 객체를 생성한다.

sally 객체는 Sally라는 사람이 보유하고 있는 특정 회사 주식의 지분을 나타낼 수 있다.

#### 접근 제어

private와 public이라는 키워드는 클래스 멤버에 대한 접근 제어를 서술한다.

특정 클래스의 객체를 사용하는 프로그램은 그 객체의 public 부분에는 직접 접근할 수 있다.

그러나 private 멤버에는 public 멤버 함수를 통해서만 접근할 수 있다.

EX) Stock 클래스의 shares 멤버의 값을 변경하려면 Stock 클래스의 public 멤버 함수 중의 하나를 사용해야한다.

public 멤버 함수는 객체의 private 멤버와 프로그램을 잇는 다리 역할을 한다는 것이다.

이와 같이 프로그램이 데이터에 직접 접근을 못하게 하는 것을 **데이터 은닉**이라 한다.

클래스 설계는 public 인터페이스와 세부적인 구현을 분리한다.

public 인터페이스는 설계의 추상화를 나타낸다.

세부적인 구현들을 따로 결합하여 추상화와 분리하는 것을 **캡슐화**라고 한다.

EX) Stock 클래스가 set_tot()를 가지고 하는 것처럼 기능적인 세부 구현을 private 부분에서 은닉하고 있는데 이는 데이터 은닉이자 캡슐화의 한 예이다.

```cpp
class Stock    // 키워드 class는 클래스 정의임을 나타냄
{
private:  // private는 public 멤버 함수를 통해서만 접근할 수 있는 클래스 멤버(데이터 은닉)
  std::string company;
  long shares;
  double share_val;
  double total_val;
  void set_tot() { total_val = shares * share_val; }

public:  // public은 그 클래스의 public 인터페이스를 구성하는 클래스 멤버(추상화)
  void acquire(const std::string % co, long n, double pr);
  void buy(long num, double price);
  void sell(long num, double price);
  void update(double price);
  void show();
};
```

#### 멤버 접근 제어: public 또는 private?

데이터를 은닉하는 것이 OOP의 기본 규칙 중 하나이기 때문에 데이터 항목들은 private 부분에 선언된다.

클래스 인터페이스를 구성하는 클래스는 멤버 함수들은 public 부분에 선언된다. (그렇지 않으면 프로그램이 그 함수 호출 불가능)

일반적으로 private 멤버 함수는 public 인터페이스를 구성하지 않는 세부적인 구현을 처리하는 데 사용된다.

클래스에 대한 디폴트 접근 제어가 private로 지정되어 있기 때문에 클래스 선언에서 키워드 private는 생략 가능하다.


### 클래스 멤버 함수의 구현

클래스 선언에서 원형으로 나타낸 멤버 함수들에 대한 코드를 제공해야 한다.

멤버 함수의 정의는 다음과 같은 두 가지 특성을 지니고 있다.

* 멤버 함수를 정의할 때, 그 멤버 함수가 어느 클래스에 속하는지 나타내기 위해 사용 범위 결정 연산자(::)를 사용해야 한다.

* 클래스 메서드는 그 클래스의 private 부분에만 접근할 수 있다.

멤버 함수의 함수 머리는 그 함수가 어느 클래스에 속하는지 나타내기 위해 사용 범위 결정 연산자(::)를 사용해야 한다.

```cpp
void Stock::update(double price)
```

이는 Stock 클래스의 멤버 함수인 update() 함수를 정의한다는 의미이다.

다른 클래스에 속해 있는 멤버 함수에 동일한 함수 이름을 사용할 수 있다는 뜻이다.

사용 범위 결정 연산자가 메서드 정의가 어느 클래스에 적용되는 것인지 알려주기 때문에 클래스 사용 범위를 가지고 있다고 말한다.

Stock 클래스에 속해 있는 다른 멤버 함수들은 같은 클래스에 속해 있기에 ::를 사용하지 않고 update() 메서드를 사용할 수 있다.

또 메서드는 클래스의 private 멤버에 접근할 수 있다.

다음은 show() 메서드는 다음과 같은 코드를 사용할 수 있다.

```cpp
cout << "회사명: " << company
     << " 주식 수: " << shares << endl
     << " 주가: $" << share_val
     << " 주식 총 가치: $" << total_val << endl;
```

위 코드에서 company, shares, share_val, total_val은 Stock 클래스의 private 데이터 멤버이다.

```cpp
// stock00.cpp -- stock 클래스 구현
// version 00
#include <iostream>
#include "stock00.h"

void Stock::acquire(const std::string & co, long n, double pr)
{
  company = co;
  if (n < 0)
  {
    std::cout << "주식 수는 음수가 될 수 없으므로, " << company << " shares를 0으로 설정합니다.\n";
    shares = 0;
  }
  else
    shares = n;
  share_val = pr;
  set_tot();
}
...
```

### 클래스 사용하기

클래스의 객체를 생성하고 사용하는 프로그램을 작성해보자.

목표는 int나 char 같은 기본 데이터형처럼 클래스를 사용하는 것이다.

* 클래스 변수를 선언해 클래스 객체를 생성할 수 있다.
  
* 클래스형의 객체를 대입하기 위해 new를 이용함으로써 클래스 객체를 생성할 수 있다.

* 객체를 매개변수로 전달할 수 있고 함수의 리턴값으로 리턴할 수 있다.

* 한 객체를 다른 객체에 대입할 수 있다.

아래의 프로그램은 stock이라는 Stock 객체를 하나 생성한다.

```cpp
// usestock0.cpp -- 고객 프로그램
// stock00.cpp와 컴파일한다.
#include <iostream>
#include "stock00.h"
int main()
{
  Stock fluffy_the_cat;
  fluffy_the_cat.acquire("NanoSmart", 20, 12.50);
  fluffy_the_cat.show();
  fluffy_the_cat.buy(15, 18.125);
  fluffy_the_cat.show();
  fluffy_the_cat.sell(400, 20.00);
  fluffy_the_cat.show();
  fluffy_the_cat.buy(300000, 40.125);
  fluffy_the_cat.show();
  fluffy_the_cat.sell(300000, 0.125);
  fluffy_the_cat.show();
}
```

다음은 프로그램의 출력이다.

```cpp
회사명: NanoSmart 주식수: 20
 주가: $12.5 주식 총 가치: $250
회사명: NanoSmart 주식수: 35
 주가: $18.125 주식 총 가치: $634.375
보유 주식보다 많은 주식을 매도할 수 없으므로, 거래가 취소되었습니다.
회사명: NanoSmart 주식수: 35
 주가: $18.125 주식 총 가치: $634.375
회사명: NanoSmart 주식수: 300035
 주가: $40.125 주식 총 가치: $1.20389e+07
회사명: NanoSmart 주식수: 35
 주가: $0.125 주식 총 가치: $4.375
```

### 실행상의 변경

위 프로그램처럼 결과가 일관적이지 않은 숫자로 나타나는 경우가 있다.

ostream 클래스는 양식을 컨트롤하는 멤버 함수를 지녔다.

```cpp
std::cout.self(std::ios_base::fixed, std::ios_base::floatfield);
```

이 코드는 플래그를 고정 소수점 표기를 사용하기 위해 cout 개체 안에 플래그를 세팅한다.

고정 소수점 표기를 사용할 때 자리 수를 지정할 수 있다.

```cpp
std::cout.precision(3);
```

이 방법들은 표기 양식을 컨트롤하기 위해서 show() 메서드에서 사용될 수 있으나 프로그램의 다른 부분에 영향을 주지 않도록 해야한다.

show()가 호출되기 이전의 상태로 정보를 리셋하는 것이 안정된 사용법이다.

```cpp
std::streamsize prec =
  std::cout.precision(3)  // 정확성을 위해 이전 값을 저장
...
std::cout.precision(prec);  // 과거 값으로 리턴한다.

// 원본 플래그를 저장한다.
std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed);
...
// 저장된 값을 리셋한다.
std::cout.self(orig, std::ios_base::floatfield);
```

fmtflag는 ios_base 클래스에서 정의된 데이터형으로 std 이름 공간에서 정의되기 때문에 orig에게는 긴 타입 이름이다.

orig는 모든 플래그를 보유하고 있으며 리셋 구문은 그 정보를 사용하여 고정 소수점 표기와 과학적 기수법을 위한 플래그를 포함하고 있는 floatfield에 있는 정보를 리셋한다.

과학적 기수법: 너무 크거나 너무 작은 숫자들을 십진법 으로 편하게 작성하여 표현하는 방법

### 지금까지의 설명 요약

클래스 설계를 서술하는 첫 번째 단계: 클래스 선언을 제공하는 것

> 클래스 선언은 구조체 선언과 모양이 비슷하다.

> 클래스 선언은 데이터 멤버와 함수 멤버를 가질 수 있다.

> 클래스 선언의 private 부분에 선언된 멤버들은 멤버 함수를 통해서만 접근 할 수 있다.

> 클래스 선언의 public 부분에 선언된 멤버들은 클래스 객체를 사용하여 프로그램이 직접 접근 할 수 있다.

다음은 클래스 선언의 일반적인 형식이다.

```cpp
class className
{
    private:
      data member declarations  // 데이터 멤버들
    public:
      member funtion prototypes  // 멤버 함수들
};
```

public 부분에 있는 내용은 설계의 추상화 부분인 public 인터페이스가 된다.

private 부분에 데이터를 넣어 캡슐화 하는 것은 데이터의 무결성을 보호하기 위한 것으로 데이터 은닉이라고 한다.

클래스의 사용은 추상화, 데이터 은닉 캡슐화라는 OOP의 목표를 쉽게 구현할 수 있게 해준다.

클래스의 설계를 서술하는 두 번째 단계: 클래스 멤버 함수를 구현하는 것

> 클래스 선언에 함수 원형 대신에 완전한 함수 저의를 넣을 수도 있다.

> 일반적으로는 매우 짧은 함수들은 제외하고 함수 정의들을 따로 분리하여 제공한다.

> 이 경우 멤버 함수가어느 클래스에 속하는지를 나타내기 위해 사용 범위 결정 연산자(::)를 사용한다.

## 10.3 클래스 생성자와 파괴자

클래스를 사용할 때 일반적으로 제공해야 하는 생성자와 파괴자라는 표준 함수가 있다.

이들이 왜 필요하고 어떻게 작성하는지 알아보자.

C++의 목표 중 하나가 클래스 객체를 표준 데이터형처럼 사용하는 것이다.

하지만 Stock형에 대해서는 일반적인 초기화 문법이 적용되지 않는다.

```cpp
int year = 2001;  // 적법한 초기화
struck thing
{
  char * pn;
  int m;
};
thing amabob = {"wodget", -23};  // 적법한 초기화
Stock hot = {"Sukie's Autos, Inc.", 200, 50.25};  // 컴파일 에러
```

Stock 객체를 초기화할 수 없는 이유는 데이터들이 private 접근 제어를 가지고 있어 프로그램이 데이터 멤버에 직접 접근할 수 없기 때문이다.

객체를 성공적으로 초기화하려면 적당한 멤버 함수를 하나 고안해야 한다.

```cpp
Stock gift;
gift.buy(10, 24.75);
```

현재까지 구현된 Stock 클래스를 그대로 사용하면 gift 객체는 company 멤버의 값을 갖지 못한다.

클래스 설계는 사용자가 다른 멤버 함수를 호출하기 전에 acquire()를 먼저 호출할 것이라 가정하지만 이런 가정을 강요하지 않는다.

이 문제를 해결하는 한 가지 방법은 객체가 생성될 때 자동으로 초기화되게 만드는 것이다.

C++는 새로운 객체를 생성하고 그들의 데이터 멤버에 값을 대입해 주는 클래스 생성자라는 특별한 멤버 함수를 제공한다.

생성자의 이름은 클래스의 이름과 같다.

Ex) Stock이라는 클래스의 생성자는 Stock()라는 이름의 멤버함수이다.

생성자는 리턴값이 없는데도 void형으로 선언하지 않고, 데이터형을 선언하지 않는다는 특징이 있다.

### 생성자의 선언과 정의

Stock 객체는 외부에서 제공되는 세 개의 값을 가지기 때문에 세 개의 매개변수를 제공해야 한다.

(total_val 멤버는 shares와 share_val로부터 계산되므로 제공할 필요 없다.)

company 멤버 값만 제공하고 다른 값들은 0으로 설정하기로 가정하면 원형은 다음과 같다.

```cpp
//  디폴트 매개변수를 사용하는 생성자의 원형
Stock(const string & co, long n = 0, double pr = 0.0);
```

이 원형은 리턴형이 없고 클래스 선언의 public 부분에 들어간다.

다음은 생성자를 위한 한 가지 정의의 예이다.

```cpp
Stock::Stock(const string & co, long n, double pr)
{
  company = co;

    if (n < 0)
    {
      std::cout << "주식 수는 음수가 될 수 없으므로, " << company << " shares를 0으로 설정합니다.\n";
      shares = 0;
    }
    else
      shares = n;
    share_val = pr;
    set_tot();
}
```

acquire() 함수와의 차이점은 생성자는 객체를 선언할 떄 프로그램이 자동으로 생성자를 호출한다는 것이다.

### 생성자 사용하기

C++는 생성자를 이용하여 객체를 초기화하는 방법을 두 가지 제공한다.

첫 번째 방법은 생성자를 명시적으로 호출하는 것이다.

```cpp
Stock food = Stock("World Cabbage", 250, 1.25);
```

food 객체의 company 멤버를 문자열 "World Cabbage"로 설정하고 shares 멤버를 250으로, share_val 멤버를 1.25로 지정한다.

두 번째 방법은 생성자를 암시적으로 호출하는 것이다.

```cpp
Stock garment("Furry Mason", 50, 2.5);
```

이 형식은 다음과 같은 명시적 호출과 동일하다.

```cpp
Stock garment = Stock("Furry Mason", 50, 2.5);
```

C++는 해당 클래스의 객체를 생성할때마다 클래스 생성자를 사용한다.

동적메모리 대입을 위해 new를 사용할 때에도 마찬가지다.

```cpp
Stock *pstock = new Stock("Electroshock Games" 18, 19.0);
```

Stock 객체를 생성하고 매개변수를 통해 제공되는 값으로 초기화한다.

그 후 객체의 주소를 pstock 포인터에 대입한다.

이 경우 객체의 이름은 없지만 포인터를 사용해 객체를 다룬다.


### 디폴트 생성자

디폴트 생자는 명시적인 초기화 값을 제공하지 않을 때 객체를 생성하는데 사용하는 생성자이다.

```cpp
Stock fluffy_the_cat;  // 디폴트 생성자를 사용한다
```

사용자가 생성자를 제공하지 않아도 C++가 자동으로 디폴트 생성자를 제공한다.

Stock 클래스의 경우 디폴트 생성자는 다음과 같다.

```cpp
Stock::Stock() { }
```

디폴트 생성자는 매개변수를 갖지 않으므로 그 선언에 아무런 값도 나타나지 않는다.

명시적인 초기화를 하지 않고 객체를 생성하고 싶은 경우 사용자 자신의 디폴트 생성자를 정의해야 한다.

디폴트 생성자는 두 가지 방법으로 정의할 수 있다.

첫 번째 방법은 기존의 생성자에 있는 모든 매개변수에 디폴트 값을 제공하는 것이다.

```cpp
Stock(const string & co = "Error", int n = 0, double pr = 0.0);
```

두 번째 방법은 함수 오버로딩을 사용하여 매개변수가 없는 또 하나의 생성자를 정의하는 것이다.

```cpp
Stock();
```

사용자는 하나의 디폴트 생성자만 가질 수 있으므로 두 가지 방법을 다 사용하여 두 개의 디폴트 생성자를 만들면 안 된다.

일반적으로는 사용자가 객체를 초기화해 주어야 하므로 디폴트 생성자는 모든 멤버들의 값에 암시적인 초기화를 제공한다.

다음은 Stock 클래스의 디폴트 생성자의 예이다.

```cpp
Stock::Stock()
{
  company = "no name";
  shares = 0;
  share_val = 0.0;
  total_vla = 0.0;
}
```

디폴트 생성자를 생성한 루에는 명시적으로 초기화 하지 않고도 객체 변수들을 선언할 수 있다.

```cpp
Stock first;  // 디폴트 생성자를 암시적으로 호출한다
Stock first = Stock();  // 디폴트 생성자를 명시적으로 호출한다
Stock *prelief = new Stock;  // 디폴트 생성자를 암시적으로 호출한다
```

### 파괴자

객체를 생성하기 위해 생성자를 사용할 때, 프로그램은 객체의 수명이 다할 때까지 객체를 추적하는 책임을 맡는다.

객체의 수명이 끝나는 시점에서 프로그램은 파괴자라는 특병한 멤버 함수를 자동으로 호출한다.

파괴자는 어떠한 흔적도 남기지 않고 깨끗하게 없애야한다.

Ex) 생성자가 new를 사용하여 메모리를 대입했다면 파괴자는 delete를 사용해서 대입된 메모리를 해제해야 한다.

파괴자는 생성자 앞에 틸데(~)를 붙이면 된다.

Stock 클래스의 파괴자는 ~Stock()이다.

생성자와 마찬가지로 리턴값을 가질 수 없고 선언된 데이터형을 갖지 않는다.

하지만 생성자와 다르게 매개변수를 가질 수 없다.

다음은 Stock 파괴자의 원형이다.

```cpp
~Stock();
```

Stock 생성자는 new를 사용하지 않아 파괴자는 별다른 할 일이 없으므로 아무 것도 하지 않는 함수로 코딩할 수 있다.

```cpp
Stock::~Stock()
{
}
```

파괴자는 언제 호출되는가?

파괴자는 일반적으로 사용자가 호출하면 안되고 컴파일러가 처리해야 한다.

* 정적 기억 공간의 클래스 객체를 생성한다면 프로그램이 종료될 때 파괴자가 자동으로 호출된다.

* 자동 기억 공간의 클래스 객체를 생성한다면 그 객체가 정의 된 코드 블록을 프로그램이 벗어날 때 파괴자가 자동으로 호출된다.

* new를 사용하여 객체를 생성한다면 그 객체는 힙 메모리 또는 자유 기억 공간에 저장되므로 그것의 메모리를 해제하기 위해 delete를 사용할 때 파괴자가 자동으로 호출된다.

* 프로그램은 어떤 작업들을 수행하기 위해 임시적인 객체를 생성할 수 있는데 프로그램은 그 객체의 사용을 마쳤을 때 파괴자를 자동으로 호출한다.

클래스 객체의 수명이 다했을 때 파괴자는 자동으로 호출되는 것이기 때문에 반드시 파괴자가 있어야 한다.

사용자가 파괴자를 제공하지 않으면 컴파일러가 디폴트 파괴자를 선언한다.

객체를 파괴하는 코드를 발견하면 컴파일러는 그 파괴자를 위한 정의를 제공한다.


### Stock 클래스 개선하기

```cpp
// stock10.h -- 생성자들과 파괴자가 추가된 Stock 클래스 선언
#ifndef STOCK10_H_
#define STOCK10_H_
#include <string>

class Stock
{
private:
  std::string company;
  long shares;
  double share_val;
  double total_val;
  void set_tot() { total_val = shares * share_val; }

public:
// 두 개의 생성자
  Stock();
  Stock(const std::string & co, long n = 0, double pr = 0.0);
  ~Stock();  // 파괴자
  void acquire(const std::string % co, long n, double pr);
  void buy(long num, double price);
  void sell(long num, double price);
  void update(double price);
  void show();
};
#endif
```

```cpp
// stock10.cpp -- 생성자들과 파괴자가 추가된 Stock 클래스 구현
#include <iostream>
#include "stock10.h"

// 생성자들
Stock::Stock()  // 디폴트 생성자
{
  std::cout << "디폴트 생성자가 호출되었습니다.\n";
  company = "no name";
  shares = 0
  share_val = 0.0;
  total_val = 0.0;
}

Stock::Stock(const std::string & co, long n, double pr)
{
  std::cout << co << "를 사용하는 생성자가 호출되었습니다.\n";
  company = co;
  if (n < 0)
  {
    std::cerr << "주식 수는 음수가 될 수 업승므로, " << company << " shares를 0으로 설정합니다.\n";
    shares = 0
  }
  else
    shares = n;
  share_val = pr;
  set total();
}
// 클래스 파괴자
Stock::~Stock()
{
  std::cout << "안녕, " << company << "!\n";
}
// 다른 메서드들
...
```

### 생성자와 파괴자에 대한 요약

* 생성자는 그 클래스의 객체가 생성될 때마다 호출되는 특별한 종류의 클래스 멤버 함수이다.

* 클래스 생성자는 그 클래스와 같은 이름을 가진다.

* 그러나 함수 오버 로딩을 통해 같은 이름을 사용하는 생성자를 하나 이상 가질 수 있다.

* 이 경우 각각의 생성자는 자신만의 유일한 시그내처 또는 매개변수 리스트를 가져야 한다.

* 생성자는 데이터형을 가지지 않는다.

* 일반적으로 생성자는 클래스 객체의 멤버를 초기화하는 데 사용된다.

* 초기화는 생성자의 매개 변수 리스트와 일치하게 이루어져야 한다.

* 디폴트 생성자는 매개변수가 없으며 명시적으로 초기화하지 않고 객체를 생성할 때 사용한다.

* 사용자가 어떠한 생성자도 제공하지 않으면 사용자를 대신하여 컴파일러가 디폴트 생성자를 정의한다.

* 객체가 파괴될 때 프로그램은 파괴자를 호출한다.

* 파괴자는 클래스당 하나만 가질 수 있다.

* 파괴자는 리턴형을 갖지 않으며 매개변수도 갖지 않는다.

* 파괴자의 이름은 클래스 이름 앞에 탈레(~)가 붙은 함수형이다.

* 클래스 파괴자는 클래스 생성자가 new를 사용할 때 필요하다.


## 10.4 객체 들여다 보기, this 포인터

지금까지 클래스의 각 멤버 함수는 그것을 호출하는 하나의 객체만을 처리했다.

그러나 하나의 메서드가 두 개의 객체를 동시에 처리해야할 수 있다.

C++은 이것을 가능하게 하기 위해 this라는 포인터를 제공한다.

S
