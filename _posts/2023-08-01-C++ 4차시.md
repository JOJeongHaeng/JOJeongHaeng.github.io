---
layout: single
title:  "2023 C++ 학습하기 4차시"
categories: coding
author_profile: false
toc: true
toc_sticky: true
toc_depth: 2
---

<head>
  <style>   
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# 10장 객체와 클래스

객체 지향 프로그래밍(OOP)은 프로그램 설계 방법중 하나이다.

C++은 객체 지향 프로그래밍을 쉽게 구현할 수 있도록 만든 프로그래밍 언어이다.

다음은 OOP의 가장 중요한 기능들이다.

* 추상화(abstraction)

* 캡슐화(encapsulation)와 데이터 은닉(data hiding)

* 다형(polymorphism)

* 상속(inheritance)

* 코드의 재활용(reusability of code)

클래스는 이러한 기능들을 구현하고 결합하는 데 사용되는 가장 중요한 C++ 도구이다.

이 장에서는 클래스가 무엇인지 알아본 후 OOP의 기능들을 설명한다.

## 10.1 절차식 프로그래밍과 객체 지향 프로그래밍

절차적 접근 방식은 처리해야 할 절차에 초점을 맞추고 데이터를 표현할 방법을 찾는다.

OOP 접근 방식은 객체를 서술하는 데 필요한 데이터와, 사용자가 그 데이터를 다루는 방법에 대해서 생각하며 사용자가 이해하는 방식대로 객체에 초점을 맞춘다.

이러한 인터페이스를 설계한 후 인터페이스와 데이터 저장 형태을 구현한다.

## 10.2 추상화와 클래스

컴퓨터 분야에서 추상화란 정보를 사용자 인터페이스로 표현하는 것이다.

즉, 어떤 문제에 대해 필수적인 조작적 요인을 추상화하고 해결책을 표현하는 것이다.

클래스가 추상화 인터페이스를 구현하는 정의 데이터형이다.

### 데이터형이란 무엇인가?

데이터형은 메모리에 저장되는 형태 뿐만 아니라 그것을 대상으로 수행할 수 있는 연산에 의해 정의된다.

int형은 사칙연산, 나머지 연산자까지 사용 가능하지만 포인터는 int형에 적용할 수 있는 연산을 허용하지 않는다.

어떤 변수를 선언한다고 할 때 단지 메모리 대입이 아닌 그 데이터형이 수행할 수 있는 연산도 함께 정의 된다는 것이다.

쉽게 말해 기본형을 서술하는 것은 다음과 같은 세 가지를 결정하는 것이다.

* 데이터 객체에 필요한 메모리의 크기를 결정한다.

* 메모리에 있는 비트들을 어떻게 해석할 것인지 결정한다. (long 값과 float 값이 메모리에서 동일한 비트를 사용해도 서로 다른 수치 값으로 해석)

* 데이터 객체를 사용하여 수행할 수 있는 연산이나 메소드를 결정한다.

내장된 기본 데이터형은 동작에 관한 정보가 컴파일러에 내장된다.

그러나 사용자 정의 데이터형은 이와 같은 정보를 직접 제공해야 한다.

### C++의 클래스

클래스는 추상화를 사용자 정의 데이터형으로 변환해 주는 C++의 수단이다.

클래스는 데이터 표현현과 데이터를 조작하는 메서드들을 하나의 패키지 안에 결합한다.

EX) 주식을 나타내는 클래스를 생각해보자

한주를 기본단위로 삼고, 한 주를 표현하는 클래스를 정의하는 것이 주식을 나타내는 방법이라면 100주를 나타낼 때 100개의 객체가 필요하다.

이렇게 하지 않고 한 사람이 어떤 한 주식에 대해 가지고 있는 지분을 기본 단위로 표현할 수 있다.

이러면 소유한 주식의 수는 데이터 표현의 일부가 된다.

클래스 서술은 두 부분으로 이루어진다.

* 클래스 선언: 데이터 멤버와 public 인터페이스, (메서드라고 부르는) 멤버 함수를 이용하여 데이터 표현을 서술한다.

* 클래스 메서드 정의: 클래스 멤버 함수가 어떻게 구현되는지를 서술한다.

간단히 말하면 클래스 선언은 **클래스의 개요**를 제공, 메서드 정의는 **세부 사항**을 제공하는 것이다.

> ### 인터페이스란 무엇인가?
>
> 인터페이스는 두 시스템(ex. 컴퓨터와 프린터, 사용자와 컴퓨터 프로그램) 간의 상호 작용을 위한 공통된 프레임 워크다.
>
> 클래스와 관련해서는 public 인터페이스를 말하는데, public은 그 클래스를 사용하는 프로그램이다.
>
> 인터페이스는 그 클래스를 작성한 누군가가 제공한 메서드들로 구성되는데, 프로그래머가 클래스 객체와 상호 작용하는 코드를 작성할 수 있게 해 준다.
>
> 예를 들어 string 객체에 들어 있는 문자들의 개수는 클래스 작성자가 제공한 size() 메서드를 사용하면 된다.
>
> size() 메서드는 사용자와 string 클래스 객체 사이의 public 인터페이스의 일부이다.

전형적으로 C++11 프로그래머들은 인터페이스를 헤더 파일의 클래스 선언 안에 위치시키고 구현 부분은 소스 코드 파일의 클래스 함수들을 위한 코드 안에 위치시킨다.

다음은 이 전형적인 스타일의 Stock 클래스 선언이다.

```cpp
// stock00.h -- Stock 클래스 인터 페이스
// version 00
#ifndef STOCK00_H_
#define STOCK00_H_

#include <string>

class Stock    // 클래스 선언
{
private:
  std::string company;
  long shares;
  double share_val;
  double total_val;
  void set_tot() { total_val = shares * share_val; }
public:
  void acquire(const std::string % co, long n, double pr);
  void buy(long num, double price);
  void sell(long num, double price);
  void update(double price);
  void show();
};

#endif
```

C++ 키워드인 class는 위 코드가 클래스 설계를 위한 정의라는 사실을 나타낸다.

class가 포함된 이 구문은 Stock을 이 새로운 클래스의 데이터형 이름으로 만든다.

이 선언으로 Stock형의 변수인 객체나 인스턴스를 선언할 수 있게 된다.

```cpp
Stock sally;
Stock solly;
```

sally와 solly라는 두 개의 객체를 생성한다.

sally 객체는 Sally라는 사람이 보유하고 있는 특정 회사 주식의 지분을 나타낼 수 있다.

#### 접근 제어

private와 public이라는 키워드는 클래스 멤버에 대한 접근 제어를 서술한다.

특정 클래스의 객체를 사용하는 프로그램은 그 객체의 public 부분에는 직접 접근할 수 있다.

그러나 private 멤버에는 public 멤버 함수를 통해서만 접근할 수 있다.

EX) Stock 클래스의 shares 멤버의 값을 변경하려면 Stock 클래스의 public 멤버 함수 중의 하나를 사용해야한다.

public 멤버 함수는 객체의 private 멤버와 프로그램을 잇는 다리 역할을 한다는 것이다.

이와 같이 프로그램이 데이터에 직접 접근을 못하게 하는 것을 **데이터 은닉**이라 한다.

클래스 설계는 public 인터페이스와 세부적인 구현을 분리한다.

public 인터페이스는 설계의 추상화를 나타낸다.

세부적인 구현들을 따로 결합하여 추상화와 분리하는 것을 **캡슐화**라고 한다.

EX) Stock 클래스가 set_tot()를 가지고 하는 것처럼 기능적인 세부 구현을 private 부분에서 은닉하고 있는데 이는 데이터 은닉이자 캡슐화의 한 예이다.

```cpp
class Stock    // 키워드 class는 클래스 정의임을 나타냄
{
private:  // private는 public 멤버 함수를 통해서만 접근할 수 있는 클래스 멤버(데이터 은닉)
  std::string company;
  long shares;
  double share_val;
  double total_val;
  void set_tot() { total_val = shares * share_val; }

public:  // public은 그 클래스의 public 인터페이스를 구성하는 클래스 멤버(추상화)
  void acquire(const std::string % co, long n, double pr);
  void buy(long num, double price);
  void sell(long num, double price);
  void update(double price);
  void show();
};
```

#### 멤버 접근 제어: public 또는 private?

데이터를 은닉하는 것이 OOP의 기본 규칙 중 하나이기 때문에 데이터 항목들은 private 부분에 선언된다.

클래스 인터페이스를 구성하는 클래스는 멤버 함수들은 public 부분에 선언된다. (그렇지 않으면 프로그램이 그 함수 호출 불가능)

일반적으로 private 멤버 함수는 public 인터페이스를 구성하지 않는 세부적인 구현을 처리하는 데 사용된다.

클래스에 대한 디폴트 접근 제어가 private로 지정되어 있기 때문에 클래스 선언에서 키워드 private는 생략 가능하다.


### 클래스 멤버 함수의 구현

클래스 선언에서 원형으로 나타낸 멤버 함수들에 대한 코드를 제공해야 한다.

멤버 함수의 정의는 다음과 같은 두 가지 특성을 지니고 있다.

* 멤버 함수를 정의할 때, 그 멤버 함수가 어느 클래스에 속하는지 나타내기 위해 사용 범위 결정 연산자(::)를 사용해야 한다.

* 클래스 메서드는 그 클래스의 private 부분에만 접근할 수 있다.

멤버 함수의 함수 머리는 그 함수가 어느 클래스에 속하는지 나타내기 위해 사용 범위 결정 연산자(::)를 사용해야 한다.

```cpp
void Stock::update(double price)
```

이는 Stock 클래스의 멤버 함수인 update() 함수를 정의한다는 의미이다.

다른 클래스에 속해 있는 멤버 함수에 동일한 함수 이름을 사용할 수 있다는 뜻이다.

사용 범위 결정 연산자가 메서드 정의가 어느 클래스에 적용되는 것인지 알려주기 때문에 클래스 사용 범위를 가지고 있다고 말한다.

Stock 클래스에 속해 있는 다른 멤버 함수들은 같은 클래스에 속해 있기에 ::를 사용하지 않고 update() 메서드를 사용할 수 있다.

또 메서드는 클래스의 private 멤버에 접근할 수 있다.

다음은 show() 메서드는 다음과 같은 코드를 사용할 수 있다.

```cpp
cout << "회사명: " << company
     << " 주식 수: " << shares << endl
     << " 주가: $" << share_val
     << " 주식 총 가치: $" << total_val << endl;
```

위 코드에서 company, shares, share_val, total_val은 Stock 클래스의 private 데이터 멤버이다.

```cpp
// stock00.cpp -- stock 클래스 구현
// version 00
#include <iostream>
#include "stock00.h"

void Stock::acquire(const std::string & co, long n, double pr)
{
  company = co;
  if (n < 0)
  {
    std::cout << "주식 수는 음수가 될 수 없으므로, " << company << " shares를 0으로 설정합니다.\n";
    shares = 0;
  }
  else
    shares = n;
  share_val = pr;
  set_tot();
}
...
```

### 클래스 사용하기

클래스의 객체를 생성하고 사용하는 프로그램을 작성해보자.

목표는 int나 char 같은 기본 데이터형처럼 클래스를 사용하는 것이다.

* 클래스 변수를 선언해 클래스 객체를 생성할 수 있다.
  
* 클래스형의 객체를 대입하기 위해 new를 이용함으로써 클래스 객체를 생성할 수 있다.

* 객체를 매개변수로 전달할 수 있고 함수의 리턴값으로 리턴할 수 있다.

* 한 객체를 다른 객체에 대입할 수 있다.

아래의 프로그램은 stock이라는 Stock 객체를 하나 생성한다.

```cpp
// usestock0.cpp -- 고객 프로그램
// stock00.cpp와 컴파일한다.
#include <iostream>
#include "stock00.h"
int main()
{
  Stock fluffy_the_cat;
  fluffy_the_cat.acquire("NanoSmart", 20, 12.50);
  fluffy_the_cat.show();
  fluffy_the_cat.buy(15, 18.125);
  fluffy_the_cat.show();
  fluffy_the_cat.sell(400, 20.00);
  fluffy_the_cat.show();
  fluffy_the_cat.buy(300000, 40.125);
  fluffy_the_cat.show();
  fluffy_the_cat.sell(300000, 0.125);
  fluffy_the_cat.show();
}
```

다음은 프로그램의 출력이다.

```cpp
회사명: NanoSmart 주식수: 20
 주가: $12.5 주식 총 가치: $250
회사명: NanoSmart 주식수: 35
 주가: $18.125 주식 총 가치: $634.375
보유 주식보다 많은 주식을 매도할 수 없으므로, 거래가 취소되었습니다.
회사명: NanoSmart 주식수: 35
 주가: $18.125 주식 총 가치: $634.375
회사명: NanoSmart 주식수: 300035
 주가: $40.125 주식 총 가치: $1.20389e+07
회사명: NanoSmart 주식수: 35
 주가: $0.125 주식 총 가치: $4.375
```

### 실행상의 변경

위 프로그램처럼 결과가 일관적이지 않은 숫자로 나타나는 경우가 있다.

ostream 클래스는 양식을 컨트롤하는 멤버 함수를 지녔다.

```cpp
std::cout.self(std::ios_base::fixed, std::ios_base::floatfield);
```

이 코드는 플래그를 고정 소수점 표기를 사용하기 위해 cout 개체 안에 플래그를 세팅한다.

고정 소수점 표기를 사용할 때 자리 수를 지정할 수 있다.

```cpp
std::cout.precision(3);
```

이 방법들은 표기 양식을 컨트롤하기 위해서 show() 메서드에서 사용될 수 있으나 프로그램의 다른 부분에 영향을 주지 않도록 해야한다.

show()가 호출되기 이전의 상태로 정보를 리셋하는 것이 안정된 사용법이다.

```cpp
std::streamsize prec =
  std::cout.precision(3)  // 정확성을 위해 이전 값을 저장
...
std::cout.precision(prec);  // 과거 값으로 리턴한다.

// 원본 플래그를 저장한다.
std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed);
...
// 저장된 값을 리셋한다.
std::cout.self(orig, std::ios_base::floatfield);
```

fmtflag는 ios_base 클래스에서 정의된 데이터형으로 std 이름 공간에서 정의되기 때문에 orig에게는 긴 타입 이름이다.

orig는 모든 플래그를 보유하고 있으며 리셋 구문은 그 정보를 사용하여 고정 소수점 표기와 과학적 기수법을 위한 플래그를 포함하고 있는 floatfield에 있는 정보를 리셋한다.

과학적 기수법: 너무 크거나 너무 작은 숫자들을 십진법 으로 편하게 작성하여 표현하는 방법

### 지금까지의 설명 요약

클래스 설계를 서술하는 첫 번째 단계: 클래스 선언을 제공하는 것

> 클래스 선언은 구조체 선언과 모양이 비슷하다.

> 클래스 선언은 데이터 멤버와 함수 멤버를 가질 수 있다.

> 클래스 선언의 private 부분에 선언된 멤버들은 멤버 함수를 통해서만 접근 할 수 있다.

> 클래스 선언의 public 부분에 선언된 멤버들은 클래스 객체를 사용하여 프로그램이 직접 접근 할 수 있다.

다음은 클래스 선언의 일반적인 형식이다.

```cpp
class className
{
    private:
      data member declarations  // 데이터 멤버들
    public:
      member funtion prototypes  // 멤버 함수들
};
```

public 부분에 있는 내용은 설계의 추상화 부분인 public 인터페이스가 된다.

private 부분에 데이터를 넣어 캡슐화 하는 것은 데이터의 무결성을 보호하기 위한 것으로 데이터 은닉이라고 한다.

클래스의 사용은 추상화, 데이터 은닉 캡슐화라는 OOP의 목표를 쉽게 구현할 수 있게 해준다.

클래스의 설계를 서술하는 두 번째 단계: 클래스 멤버 함수를 구현하는 것

> 클래스 선언에 함수 원형 대신에 완전한 함수 저의를 넣을 수도 있다.

> 일반적으로는 매우 짧은 함수들은 제외하고 함수 정의들을 따로 분리하여 제공한다.

> 이 경우 멤버 함수가어느 클래스에 속하는지를 나타내기 위해 사용 범위 결정 연산자(::)를 사용한다.

## 10.3 클래스 생성자와 파괴자

클래스를 사용할 때 일반적으로 제공해야 하는 생성자와 파괴자라는 표준 함수가 있다.

이들이 왜 필요하고 어떻게 작성하는지 알아보자.

C++의 목표 중 하나가 클래스 객체를 표준 데이터형처럼 사용하는 것이다.

하지만 Stock형에 대해서는 일반적인 초기화 문법이 적용되지 않는다.

```cpp
int year = 2001;  // 적법한 초기화
struck thing
{
  char * pn;
  int m;
};
thing amabob = {"wodget", -23};  // 적법한 초기화
Stock hot = {"Sukie's Autos, Inc.", 200, 50.25};  // 컴파일 에러
```

Stock 객체를 초기화할 수 없는 이유는 데이터들이 private 접근 제어를 가지고 있어 프로그램이 데이터 멤버에 직접 접근할 수 없기 때문이다.

객체를 성공적으로 초기화하려면 적당한 멤버 함수를 하나 고안해야 한다.

```cpp
Stock gift;
gift.buy(10, 24.75);
```

현재까지 구현된 Stock 클래스를 그대로 사용하면 gift 객체는 company 멤버의 값을 갖지 못한다.

클래스 설계는 사용자가 다른 멤버 함수를 호출하기 전에 acquire()를 먼저 호출할 것이라 가정하지만 이런 가정을 강요하지 않는다.

이 문제를 해결하는 한 가지 방법은 객체가 생성될 때 자동으로 초기화되게 만드는 것이다.

C++는 새로운 객체를 생성하고 그들의 데이터 멤버에 값을 대입해 주는 클래스 생성자라는 특별한 멤버 함수를 제공한다.

생성자의 이름은 클래스의 이름과 같다.

Ex) Stock이라는 클래스의 생성자는 Stock()라는 이름의 멤버함수이다.

생성자는 리턴값이 없는데도 void형으로 선언하지 않고, 데이터형을 선언하지 않는다는 특징이 있다.

### 생성자의 선언과 정의

Stock 객체는 외부에서 제공되는 세 개의 값을 가지기 때문에 세 개의 매개변수를 제공해야 한다.

(total_val 멤버는 shares와 share_val로부터 계산되므로 제공할 필요 없다.)

company 멤버 값만 제공하고 다른 값들은 0으로 설정하기로 가정하면 원형은 다음과 같다.

```cpp
//  디폴트 매개변수를 사용하는 생성자의 원형
Stock(const string & co, long n = 0, double pr = 0.0);
```

이 원형은 리턴형이 없고 클래스 선언의 public 부분에 들어간다.

다음은 생성자를 위한 한 가지 정의의 예이다.

```cpp
Stock::Stock(const string & co, long n, double pr)
{
  company = co;

    if (n < 0)
    {
      std::cout << "주식 수는 음수가 될 수 없으므로, " << company << " shares를 0으로 설정합니다.\n";
      shares = 0;
    }
    else
      shares = n;
    share_val = pr;
    set_tot();
}
```

acquire() 함수와의 차이점은 생성자는 객체를 선언할 떄 프로그램이 자동으로 생성자를 호출한다는 것이다.

### 생성자 사용하기

C++는 생성자를 이용하여 객체를 초기화하는 방법을 두 가지 제공한다.

첫 번째 방법은 생성자를 명시적으로 호출하는 것이다.

```cpp
Stock food = Stock("World Cabbage", 250, 1.25);
```

food 객체의 company 멤버를 문자열 "World Cabbage"로 설정하고 shares 멤버를 250으로, share_val 멤버를 1.25로 지정한다.

두 번째 방법은 생성자를 암시적으로 호출하는 것이다.

```cpp
Stock garment("Furry Mason", 50, 2.5);
```

이 형식은 다음과 같은 명시적 호출과 동일하다.

```cpp
Stock garment = Stock("Furry Mason", 50, 2.5);
```

C++는 해당 클래스의 객체를 생성할때마다 클래스 생성자를 사용한다.

동적메모리 대입을 위해 new를 사용할 때에도 마찬가지다.

```cpp
Stock *pstock = new Stock("Electroshock Games" 18, 19.0);
```

Stock 객체를 생성하고 매개변수를 통해 제공되는 값으로 초기화한다.

그 후 객체의 주소를 pstock 포인터에 대입한다.

이 경우 객체의 이름은 없지만 포인터를 사용해 객체를 다룬다.


### 디폴트 생성자

디폴트 생자는 명시적인 초기화 값을 제공하지 않을 때 객체를 생성하는데 사용하는 생성자이다.

```cpp
Stock fluffy_the_cat;  // 디폴트 생성자를 사용한다
```

사용자가 생성자를 제공하지 않아도 C++가 자동으로 디폴트 생성자를 제공한다.

Stock 클래스의 경우 디폴트 생성자는 다음과 같다.

```cpp
Stock::Stock() { }
```

디폴트 생성자는 매개변수를 갖지 않으므로 그 선언에 아무런 값도 나타나지 않는다.

명시적인 초기화를 하지 않고 객체를 생성하고 싶은 경우 사용자 자신의 디폴트 생성자를 정의해야 한다.

디폴트 생성자는 두 가지 방법으로 정의할 수 있다.

첫 번째 방법은 기존의 생성자에 있는 모든 매개변수에 디폴트 값을 제공하는 것이다.

```cpp
Stock(const string & co = "Error", int n = 0, double pr = 0.0);
```

두 번째 방법은 함수 오버로딩을 사용하여 매개변수가 없는 또 하나의 생성자를 정의하는 것이다.

```cpp
Stock();
```

사용자는 하나의 디폴트 생성자만 가질 수 있으므로 두 가지 방법을 다 사용하여 두 개의 디폴트 생성자를 만들면 안 된다.

일반적으로는 사용자가 객체를 초기화해 주어야 하므로 디폴트 생성자는 모든 멤버들의 값에 암시적인 초기화를 제공한다.

다음은 Stock 클래스의 디폴트 생성자의 예이다.

```cpp
Stock::Stock()
{
  company = "no name";
  shares = 0;
  share_val = 0.0;
  total_vla = 0.0;
}
```

디폴트 생성자를 생성한 루에는 명시적으로 초기화 하지 않고도 객체 변수들을 선언할 수 있다.

```cpp
Stock first;  // 디폴트 생성자를 암시적으로 호출한다
Stock first = Stock();  // 디폴트 생성자를 명시적으로 호출한다
Stock *prelief = new Stock;  // 디폴트 생성자를 암시적으로 호출한다
```

### 파괴자

객체를 생성하기 위해 생성자를 사용할 때, 프로그램은 객체의 수명이 다할 때까지 객체를 추적하는 책임을 맡는다.

객체의 수명이 끝나는 시점에서 프로그램은 파괴자라는 특병한 멤버 함수를 자동으로 호출한다.

파괴자는 어떠한 흔적도 남기지 않고 깨끗하게 없애야한다.

Ex) 생성자가 new를 사용하여 메모리를 대입했다면 파괴자는 delete를 사용해서 대입된 메모리를 해제해야 한다.

파괴자는 생성자 앞에 틸데(~)를 붙이면 된다.

Stock 클래스의 파괴자는 ~Stock()이다.

생성자와 마찬가지로 리턴값을 가질 수 없고 선언된 데이터형을 갖지 않는다.

하지만 생성자와 다르게 매개변수를 가질 수 없다.

다음은 Stock 파괴자의 원형이다.

```cpp
~Stock();
```

Stock 생성자는 new를 사용하지 않아 파괴자는 별다른 할 일이 없으므로 아무 것도 하지 않는 함수로 코딩할 수 있다.

```cpp
Stock::~Stock()
{
}
```

파괴자는 언제 호출되는가?

파괴자는 일반적으로 사용자가 호출하면 안되고 컴파일러가 처리해야 한다.

* 정적 기억 공간의 클래스 객체를 생성한다면 프로그램이 종료될 때 파괴자가 자동으로 호출된다.

* 자동 기억 공간의 클래스 객체를 생성한다면 그 객체가 정의 된 코드 블록을 프로그램이 벗어날 때 파괴자가 자동으로 호출된다.

* new를 사용하여 객체를 생성한다면 그 객체는 힙 메모리 또는 자유 기억 공간에 저장되므로 그것의 메모리를 해제하기 위해 delete를 사용할 때 파괴자가 자동으로 호출된다.

* 프로그램은 어떤 작업들을 수행하기 위해 임시적인 객체를 생성할 수 있는데 프로그램은 그 객체의 사용을 마쳤을 때 파괴자를 자동으로 호출한다.

클래스 객체의 수명이 다했을 때 파괴자는 자동으로 호출되는 것이기 때문에 반드시 파괴자가 있어야 한다.

사용자가 파괴자를 제공하지 않으면 컴파일러가 디폴트 파괴자를 선언한다.

객체를 파괴하는 코드를 발견하면 컴파일러는 그 파괴자를 위한 정의를 제공한다.


### Stock 클래스 개선하기

```cpp
// stock10.h -- 생성자들과 파괴자가 추가된 Stock 클래스 선언
#ifndef STOCK10_H_
#define STOCK10_H_
#include <string>

class Stock
{
private:
  std::string company;
  long shares;
  double share_val;
  double total_val;
  void set_tot() { total_val = shares * share_val; }

public:
// 두 개의 생성자
  Stock();
  Stock(const std::string & co, long n = 0, double pr = 0.0);
  ~Stock();  // 파괴자
  void acquire(const std::string % co, long n, double pr);
  void buy(long num, double price);
  void sell(long num, double price);
  void update(double price);
  void show();
};
#endif
```

```cpp
// stock10.cpp -- 생성자들과 파괴자가 추가된 Stock 클래스 구현
#include <iostream>
#include "stock10.h"

// 생성자들
Stock::Stock()  // 디폴트 생성자
{
  std::cout << "디폴트 생성자가 호출되었습니다.\n";
  company = "no name";
  shares = 0
  share_val = 0.0;
  total_val = 0.0;
}

Stock::Stock(const std::string & co, long n, double pr)
{
  std::cout << co << "를 사용하는 생성자가 호출되었습니다.\n";
  company = co;
  if (n < 0)
  {
    std::cerr << "주식 수는 음수가 될 수 업승므로, " << company << " shares를 0으로 설정합니다.\n";
    shares = 0
  }
  else
    shares = n;
  share_val = pr;
  set total();
}
// 클래스 파괴자
Stock::~Stock()
{
  std::cout << "안녕, " << company << "!\n";
}
// 다른 메서드들
...
```

### 생성자와 파괴자에 대한 요약

* 생성자는 그 클래스의 객체가 생성될 때마다 호출되는 특별한 종류의 클래스 멤버 함수이다.

* 클래스 생성자는 그 클래스와 같은 이름을 가진다.

* 그러나 함수 오버 로딩을 통해 같은 이름을 사용하는 생성자를 하나 이상 가질 수 있다.

* 이 경우 각각의 생성자는 자신만의 유일한 시그내처 또는 매개변수 리스트를 가져야 한다.

* 생성자는 데이터형을 가지지 않는다.

* 일반적으로 생성자는 클래스 객체의 멤버를 초기화하는 데 사용된다.

* 초기화는 생성자의 매개 변수 리스트와 일치하게 이루어져야 한다.

* 디폴트 생성자는 매개변수가 없으며 명시적으로 초기화하지 않고 객체를 생성할 때 사용한다.

* 사용자가 어떠한 생성자도 제공하지 않으면 사용자를 대신하여 컴파일러가 디폴트 생성자를 정의한다.

* 객체가 파괴될 때 프로그램은 파괴자를 호출한다.

* 파괴자는 클래스당 하나만 가질 수 있다.

* 파괴자는 리턴형을 갖지 않으며 매개변수도 갖지 않는다.

* 파괴자의 이름은 클래스 이름 앞에 탈레(~)가 붙은 함수형이다.

* 클래스 파괴자는 클래스 생성자가 new를 사용할 때 필요하다.


## 10.4 객체 들여다 보기, this 포인터

지금까지 클래스의 각 멤버 함수는 그것을 호출하는 하나의 객체만을 처리했다.

그러나 하나의 메서드가 두 개의 객체를 동시에 처리해야할 수 있다.

C++은 이것을 가능하게 하기 위해 this라는 포인터를 제공한다.

두 개의 Stock 객체를 조사하여 둘 중 더 큰 것에 대한 참조를 리턴하는 멤버 함수를 정의해보자

이것을 구현하여 할 때 몇 가지 질문이 있다.

>첫째, 비교할 두 개의 객체를 그 멤버 함수에 어떤 방법으로 제공할 것인가?
>
>Ex) topval()이라는 이름으로 메서드를 만들었다면 stock1.topval()와 stock2.topval() 함수 호출은 각각 stock1, stock2 객체의 데이터에 접근한다.
>
>이 메서드로 두 객체를 비교하려면 두 번째 객체를 매개변수로 전달해야 하는데 이 경우에 매개변수를 참조로 전달 하는 것이 효율적이다.
>
>즉, topval() 메서드가 const Stock &형의 매개변수를 사용하도록 할 수 있다.

>둘째, 그 메서드의 응답을 호출 프로그램에 어떤 방법으로 알릴 것인가?
>
>가장 직접적인 방법은 둘 중 주식 가치가 더 큰 객체에 대한 참조를 그 메서드가 리턴하는 것이다.
>
>그러므로 메서드의 원형은 다음과 같다.

```cpp
const Stock & topval(const Stock & s) const;
```

이 함수는 한 객체에는 암시적으로 접근, 다른 객체에는 명시적으로 접근한다.

그 후 두 객체 중의 하나에 대한 참조를 리턴한다.

괄호 안에 있는 const는 그 함수가 명시적으로 접근된 객체를 변경하지 않는다는 뜻이다.

광호 뒤에 있는 const는 그 함수가 암시적으로 접근한 객체를 변경하지 않는다는 뜻이다.

두 const 객체 중 어느 하나에 대한 참조를 리턴하기 때문에 리턴형도 const 참조이다.

```cpp
top = stock1.topval(stock2);
top = stock2.topval(stock1);
```

topval() 메서드의 부분적 구현이다.

```cpp
const Stock & Stock::topval(const Stock & s) const
{
  if (s.total_val > total.val)
    return s;    // 매개변수로 전달받은 객체
  else
    return ?????;  // 메서드를 호출한 객체
}
```

여기서 s.total_val은 매개변수로 전달된 객체의 주식 총 가치이고 total_val은 메세지를 전달받은 객체의 주식 총 가치이다.

s.total_val이 total_val보다 크면 함수는 s를 리턴하지만 그렇지 않으면 메서드를 호출하는 데 사용된 객체를 리턴한다.

문제는 그 객체를 어떻게 불러야할지이다.

C++에서는 해결 방법으로 this 포인터를 사용한다.

this 포인터는 멤버 함수를 호출하는 데 사용된 객체를 지시한다.

this는 그 객체의 주소이기 때문에 객체 자체를 리턴하기 위해 참조 연산자 *를 붙여야 한다.

```cpp
const Stock & Stock::topval(const Stock & s) const
{
  if (s.total_val > total.val)
    return s;    // 매개변수로 전달받은 객체
  else
    return *this;  // 메서드를 호출한 객체
}
```

## 10.5 객체 배열

같은 클래스에 속하는 객체를 여러 개 생성하기 원할 때 객체들로 이루어진 배열을 생성할 수 있다.

객체 배열은 표준 데이터형의 배열을 선언하는 것과 동일한 방법으로 선언한다.

```cpp
Stock mystuff[4];  // 4개의 Stock 객체로 이루어진 배열을 생성한다.
```

배열의 각 원소는 Stock 객체이므로 Stock 메서드들과 함께 사용할 수 있다.

```cpp
mystuff[0].update();
```

생성자를 사용해 배열의 원소를 초기화할 수 있는데 이 경우 각 원소에 대해 생성자를 호출해야 한다.

```cpp
const int STKS = 4;
Stock stocks[STKS] = {
  Stock("NanoSmart", 12.5, 20),
  Stock("Boffo Object", 200, 2.0),
  Stock("Monolithoc Obelisks", 130, 3.25),
  Stock("Fleep Enterprises", 60, 6.5)
};
```

아래 코드는 Stock(const char * co, long n, double pr) 생성자를 사용해 stock[0]과 stock[2]를 초기화 하고 Stock() 생성자를 사용하여 stock[1]을 초기화한다.

이 선언은 배열의 일부만 초기화하기 때문에 나머지 7개의 원소는 디폴트 생성자를 사용해 초기화한다.

```cpp
const int STKS = 10;
Stock stocks[STKS] = {
  Stock("NanoSmart", 12.5, 20),
  Stock(),
  Stock("Monolithoc Obelisks", 130, 3.25),
};
```


## 10.6 클래스 사용 범위

클래스 사용 범위는 클래스 데이터 멤버들의 이름이나 클래스 멤버 함수들의 이름과 같이 클래스 안에서 정의되는 이름들에 적용된다.

클래스 사용 범위를 갖는 것들은 클래스 안에만 알려지므로 서로 다른 클래스에 같은 이름으로 선언해도 충돌하지 않는다.

Ex) Stock 클래스의 shares 멤버와 JobRide 클래스의 shares 멤버는 완전히 다른 변수이다.

사용자가 바깥 세계에서 클래스 멤버들에 직접 접근할 수 없다는 것을 의미하기도 한다.


* 클래스 사용 범위 상수

Ex) Stock 클래스 선언은 company 배열의 크기를 지정하기 위해 리터럴 30을 사용한다.

그 상수 30이 모든 객체들에 대해 동일하기 때문에 모든 객체들이 공유하는 하나의 상수로 만드는 것도 좋다.

```cpp
class Stock
{
private:
  const int Months = 12;  // 상수를 선언하는 것은 실패한다
  double costs[Months];
...
}
```

클래스를 선언하는 것은 객체가 어떻게 생겼는지를 서술하는 것이지, 객체를 생성하는 것이 아니기 때문에 위 코드는 동작하지 않는다.

따라서 값을 저장할 기억 공간은 객체가 생성될 때까지 마련되지 않는다.

두 가지 방법으로 의도했던 바를 이룰 수 있다.

> 첫째, 클래스 안에 열거체를 선언할 수 있다.
> 
> 클래스 선언안에 주어지는 열거체는 클래스 사용 범위를 가지기 때문에, 열거체를 사용함으로써 클래스 사용 범위를 가지는 기호 이름들을 정수 상수들에 제공할 수 있다.
>
> Ex) BAakery 선언을 다음과 같이 시작할 수 있다.
>
> ```cpp
> class Bakery
> {
> private:
>   enum {Months = 12;};
>   double consts[Months];
>   ...
> }
> ```
>
> 이러한 방식으로 열거체를 선언하는 것은 클래스 데이터 멤버를 생성하지 않는다.
>
> 즉, 개별적인 각 객체는 그 안에 열거체를 담지 않는다.
>
> 컴파일할 때 클래스 사용 범위에 들어 있는 코드에서 기호 이름 Len이 발견되면 컴파일러는 그것을 단순히 30으로 대체한다.
>
> 여기에서 사용되는 열거체는 열거체 변수를 생성하기 위한 것이 아니라 단순히 기호 상수를 생성하기 위한 것으로 열거체 태그를 제공할 필요가 없다.

> 둘째, 키워드 static을 이용해 클래스 안에 상수를 정의할 수 있다.
>
> ```cpp
> class Bakery
> {
> private:
>   static const int Months = 12;
>   double costs [Months];
>   ...
> }
> ```
> 
> 이것은 객체 안이 아니라 다른 정적 변수들과 함께 저장되는 Months라는 하나의 상수를 생성한다
>
> 그래서 모든 Bakery 객체들이 하나의 Month 상수를 공유한다.

### 범위가 정해진 열거(C++11)

전통적인 열거는 몇 가지 문제점을 가지고 있는데 그 중 하나는 두 개의 다른 enum 정의로 부터 온 열거자는 충돌한다는 것이다.

계란과 티셔츠 관련 프로젝트를 가정해보자

```cpp
enum egg {Small, Medium, Large, Jumbo};
enum t_shirt {Small, Medium, Lage, Xlarge};
```

이 구문은 제대로 작동하지 못하는데 egg Small과 t_shirt Small은 모두 동일한 범위에 있어 서로 충돌이 발생하기 때문이다.

C++11에서는 새로운 열거자 형식을 제공하여 열거자에게 클래스 범위를 갖게 함으로써 이러한 문제를 해결한다.

```cpp
enum class egg {Small, Medium, Large, Jumbo};
enum class t_shirt {Small, Medium, Lage, Xlarge};
```

또 다른 방법으로, 클래스 대신에 struct 키워드를 사용할 수 있다.

두 가지 경우 모두 열거자를 충족하기 위해서는 enum 이름을 사용해야한다.

```cpp
egg choice = egg::Large;
t_shirt Floyd = t_shirt::Large;
```

열거자는 클래스 범위를 지니고 있어 다른 enum 정의로부터 온 열거자와 이름이 충돌하지 않는다.


## 10.7 추상화 데이터형

클래스를 사용하는 것은 컴퓨터 과학자들이 추상형 데이터형(ADT)을 구현할 수 있는 좋은 방법이다.

ADT는 언어나 시스템의 세부적인 것들을 따지지 않고 데이터형을 일반적인 형식으로 서술한다.

> Ex) 스탯을 사용함으로써 데이터의 추가나 삭제가 꼭대기에서 이루어지도록 데이터를 저장할 수 있다.
> C++ 프로그램은 스택을 사용하여 자동 변수를 관리한다. 새로 생성되는 자동 변수는 스택의 꼭대기에 추가된다. 자동 변수의 수명이 다하면 스택에서 삭제된다.

스택의 특성을 추상적인 방식으로 살펴보자.

스택은 여러개의 항목을 저장한다. 그 다음 다은과 같은 연산을 수행할 수 있는 특성을 가지고 있다.

* 빈 스택을 생성할 수 있다.

* 스택의 꼭대기에 항목을 추가할 수 있다.

* 스택의 꼭대기에서 항목을 삭제할 수 있다.

* 스택이 가득 차 있는지 검사할 수 있다.

* 스택이 비어 있는지 검사할 수 있다.

public 멤버 함수들로 스택 연산을 나타내는 인터페이스를 제공하는 클래스 선언과 이 서술을 대응시킬 수 있다.

스택의 데이터 저장은 private 데이터 멤버들이 담당한다. 그러한 클래스 개념은 ADT 접근과 부합한다.

private 부분은 데이터 저장 방법을 정해야한다.

예들들어 일반 배열, 동적 대입 배열, 링크드 리스트,또는 더 높은 수준의 데이터 구조를 사용할 수 있다.

그러나 public 인터페이스는 정확한 표현이 드러나지 않게 해야하므로 스택을 생성한다.

```cpp
// stack.h -- 스택 ADT를 위한 클래스 정의
#ifndef STACK_H_
#define STACK_H_

typedef unsigned long Item;

class Stack
{
private:
  enum {MAX = 10};  // 클래스용 상수  
  Item items[Max];  // 스택 항목들을 저장
  int top;          // 스택의 꼭대기 항목
public:
  Stack();
  bool isempty() const;
  bool isfull() const;
  // push()는 스택이 가득 차 있으면 false 아니면 true를 리턴
  bool push(const Item & item);    // 스택에 항목을 추가
  // pop()는 스택이 비어 있으면 false 아니면 true를 리턴
  bool pop(Item & item);           // 꼭대기 항목을 꺼내 item에 넣음
};
#endif
```

private 부분은 스택이 배열로 구현되었다. 그러나 public 부분은 그 사실이 들어나지 않아 사용자는 클래스 인터페이스를 변경하지 않고 그 배열을 동적 배열로 교페할 수 있다.

스택 구현을 변경하더라도 그 스택을 사용하는 프로그램들은 다시 작성할 필요 없는다는 뜻이다. 스택 구현 코드만 다시 컴파일하여 기존의 프로그램 코드와 링크하면 된다.

이 인터페이스는 pop()과 push()가 void형이 아닌 스택 상태에 대한 정보를 리턴하기 때문에, 스택 한계의 초과를 처리하거나 스택을 비우는 것과 관련해 두 가지 옵션을 제공한다.

프로그래머는 스택을 변경하려는 시도를 하기 전에 isempty()와 isfull()을 사용해 스택을 검사할 수 있다.

그 클래스는 스택을 어떤 특정형으로 정의하지 않고 하나의 일반적인 Item형으로 스택을 서술한다. 이 경우 헤더 파일이 typedef을 사용하여 Item을 unsigned long과 같은 것으로 만든다.

하지만 사용자가 double형의 스택을 원한다면 typedef만 변경하면 된다.

클래스 메서드들을 구현해보자

```cpp
// stack.cpp -- Stack 클래스의 멤버 함수들
#include "stack.h"
Stack::Stack()
{
  top = 0;
}

bool Stack::isempty() const
{
  return top == 0;
}

bool Stack::isfull() cons
{
  return top == MAX;
}

bool Stack::push(const Item & item)
{
  if (top < MAX)
  {
    items[top++] = item;
    return true;
  }
  else 
    return false;
}

bool Stack::pop(Item & item)
{
  if (top > 0)
  {
    item = items[--top];
    return true;
  }
  else
    return false;
}
```

다음은 쌓여 있는 주문서를 처리하는 사무원의 생활을 스택의 후입선출 방식으로 모델링한 것이다.

```cpp
// stacker.cpp -- Stack 클래스를 테스트한다.
#include <iostream>
#include <cctype>
#include "stack.h"
int main()
{
  using namespace std;
  Stack st;
  char ch;
  unsigned long po;
  cout << "주문서를 추가하려면 A, 주문서를 처리하려면 P,\n"
       << " 종료하려면 Q를 입력하십시오.\n";
  while (cin >> ch && toupper(ch) != 'Q')
  {
    while (cin.get() != '\n')
      continue;
    if (!isalpha(ch))
    {
      cout << '\a';
      continue;
    }
    switch (ch)
    {
      case 'A':
      case 'a': cout << "추가할 주문서의 번호를 입력하십시오: ";
                cin >> po;
                if (st.isfull())
                  cout << "스택이 가득 차 있습니다.\n";
                else
                  st.push(po);
                break;
      case 'P':
      case 'p': if (st.isempty())
                  cout << "스택이 비어 있습니다.\n";
                else {
                  st.pop(po);
                  cout << "#" << po << " 주문서를 처리했습니다.\n";
                }
                break;
    }
  cout << "주문서를 추가하려면 A, 주문서를 처리하려면 P,\n"
       << " 종료하려면 Q를 입력하십시오.\n";
  }
  cout << "프로그램을 종료합니다.\n";
  return 0;
}
```

# 11장 클래스의 활용

이 장에서는 클래스의 일반적인 규칙보다는 클래스 설계 테크닉에 더 중점을 두면서 클래스의 특성에 대해 알아본다.

연산자 오버로팅에 대해 먼저 설면한다. =나 +와 같은 C++의 표준 연산자를 클래스 객체에 사용할 수 있게 해주는 것이다.

그 후 프렌드를 설명한다. 멤버 함수가 아닌 함수가 private 데이터에 접근할 수 있게 해주는 C++의 메커니즘이다.

마지막으로 클래스를 가지고 자동 데이터형 변환을 수행하도록 C++에게 지시하는 방법을 설명한다.

## 11.1 연산자 오버로딩

연산자 오버로딩은 C++가 가진 다형 특성의 한 예이다.

함수 오버로딩의 목적은 적용할 데이터형이 서로 다르더라도 동일한 함수 이름으로 동일한 연산을 수행하도록 하자는 것이다.

연산자 오버로딩은 그러한 오버로딩의 개념을 연산자에 확장하여 다중적인 의미를 부여하는 것이다.

> Ex) \* 연산자는  주소에 적용되면 그 주소에 저장되어 있는 값을 산출한다. 그러나 두 값 사이에 \*를 적용하면 그 값들의 곱을 산출한다.

C++에서는 연산자 오버로딩을 사용자 정의 데이터형에도 적용할 수 있다.

> Ex) 2개의 배열을 더하는 것은 일반적으로 for 루프를 사용하여 계산을 처리하지만 배열을 나타내는 클래스를 정의하고 + 연산자를 오버로딩하면 더 간단하게 처리할 수 있다.
>
> ```cpp
> for (int i = 0; i < 20; i++)
>   evening[i] = sam[i] + janet[i];
> ```
> ```cpp
> evening = sam + janet;
> ```

연산자를 오버로딩하려면 연산자 함수라는 특별한 함수를 사용해야한다.

```cpp
operatorop(argument-list)
```

여기서 op는 오버로딩할 연산자를 나타내는 기호이다.

> Ex) operator+()는  + 연산자를 오버로딩한다.
>
> \+ 연산자를 오버로딩한 operator+() 멤버 함수를 정의하고 있는 Salesperson이라는 클래스를 가지고 있다고 가정하자.
> 그리고 disrict2, sid, sara가 모두 Salesperson 클래스의 객체들이라면 다음과 같은 수식을 작성할 수 있다.
>
> ```cpp
> disrict2 = sid + sara;
> ```
>
> 피연산자들이 Salesperson 클래스에 속한다는 것을 컴파일러가 인식하면, 컴파일러는 그 연산자를 해당하는 연산자 함수로 대체한다.
>
> ```cpp
> disrict2 = sid.operator+(sara);
> ```
>
> 이 함수는 합계를 계산해 리턴하기 위해 sid 객체를 암시적으로 사용하고 sara 객체를 명시적으로 사용한다.
>
> 함수 표기 대신 손쉬운 + 연산자 표기를 사용할 수 있다는 장점이있다.


## 11.2 잠깐의 휴식: 연산자 오버로딩 예제

```cpp
// mytime0.h -- Time 클래스 (연산자 오버로딩 이전)
#ifndef MYTIME0_H_
#define MYTIME0_H_

class Time
{
private:
  int hours;
  int minutes;
public:
  Time();
  Time(int h, int m = 0);
  void AddMin(int m);
  void AddHr(int h);
  void Reset(int h = 0, int m = 0);
  Time Sum(const Time & t) const;
  void Show() const;
};
#endif
```

Time 클래스는 시간을 조정하고 재설정하는 메서드, 시간을 출력하는 메서드, 두 개의 시간을 더하는 메서드를 제공한다.

다음은 그러한 메서드들의 정의이다.

```cpp
// mytime0.cpp -- Time 클래스의 메서드 구현
#include <iostream>
#include "mytime0.h"

Time::Time()
{
  hours = minutes = 0;
}

Time::Time(int h, int m)
{
  hours = h;
  minutes = m;
}

void Time::AddMin(int m)
{
  minutes += m;
  hours += minutes / 60;
  minutes %= 60;
}

void Time::AddHr(int h)
{
  hour += h;
}

void Time::Reset(int h, int m)
{
  hours = h;
  minutes = m;
}

Time Time::Sum(const Time & t) const
{
  Time Sum;
  sum.minutes = minutes + t.minutes;
  sum.hours = hours + t.hours + sum.minutes / 60;
  sun.minutes %= 60;
  return sum;
}

void Time::Show() const
{
  std::cout << hours << "시간, " << minutes << "분";
}
```

### 덧셈 연산자의 추가

Time 클래스를 오버로딩된 덧셈 연사자를 사용하는 버전으로 변환하는 것은 Sum()의 이름을 operator+()라는 이름으로 바꾸면된다.

```cpp
// mytime0.h -- Time 클래스 (연산자 오버로딩 이후)
#ifndef MYTIME0_H_
#define MYTIME0_H_

class Time
{
private:
  int hours;
  int minutes;
public:
  Time();
  Time(int h, int m = 0);
  void AddMin(int m);
  void AddHr(int h);
  void Reset(int h = 0, int m = 0);
  Time operator(const Time & t) const;
  void Show() const;
};
#endif
```

```cpp
Time Time::operator+(const Time & t) const
{
  Time Sum;
  sum.minutes = minutes + t.minutes;
  sum.hours = hours + t.hours + sum.minutes / 60;
  sun.minutes %= 60;
  return sum;
}
```

sum()이 사용하는 것과 동일한 문법을 사용하여 operator+() 메서드를 호출할 수 있다.

```cpp
total = coding.operator+(fixing);
```

메서드 이름을 operator+()로 붙였기 때문에 다음과 같은 연산자 표기를 사용할 수 있다.

```cpp
total = coding + fixing;
```


### 오버로딩 제약

오버로딩된 연산자들이 반드시 멤버 함수일 필요는 없다. 그러나 피연산자 중에 적어도 하나는 사용자 정의 데이터형이어야 한다.

사용자 정의 연산자 오버로딩에 부가하고 있는 제약에 대해 자세히 살펴보자

* 오버로딩된 연산자는 적어도 하나의 피연산자가 사용자 정의 데이터형일 것을 요구한다.
* 이 제약안 표준
