---
layout: single
title:  "2023 C++ 학습하기 3차시"
categories: coding
toc: true
toc_sticky: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# 07장 함수 C++의 프로그래밍 모듈

## 07.1 함수의 기초(복습)

C++에서 함수를 사용하려면 다음과 같은 작업을 해야 한다.

> 함수 정의 제공

> 함수 원형 제공

> 함수 호출

직접 함수를 만들 때에는 함수 정의 제공, 함수 원형 제공, 함수 호출 이 세 가지를 사용자가 해야한다.

다음은 이 세 가지 단계를 보여 주는 간단한 예제이다.

```cpp
// calling.cpp -- 함수 정의, 함수 원형, 함수 호출
#include <iostream>

void sample();  // 함수 원형

int main()
{
  using namespace std;
  cout << "main()에서 simple() 함수를 호출합니다:\n";
  simple();  // 함수 호출
  cout << "main()이 simple() 함수와 종료됩니다:\n";
//cin.get()
  return 0;
}

// 함수 정의
void sample()
{
  using namespace std;
  cout << "여기는 sample() 함수입니다.\n";
}
```


* 함수 정의

  함수는 리턴값이 있는 함수, 리턴값이 없는 함수 두 그룹으로 나눌 수 있다.

  리턴값이 없는 함수를 void형 함수라 한다.

  일반적인 사용 형식은 다음과 같다.

  ```cpp
  void functionName(parameterList)
  {
    statement(s)
    return;    // 생략 가능
  }
  ```

  리턴값이 있는 함수는 자신을 호출한 함수에게 되돌려 줄 리턴값을 만든다.

  일반적인 사용 형식은 다음과 같다.

  ```cpp
  typeName functionName(parameterList)
  {
    statement(s)
    return value;    // value는 typeName형으로 변환된다.
  }
  ```


* 함수 원형과 함수 호출

  **함수 원형은 왜 필요한가?**

  함수 원형은 컴파일러에게 함수의 인터페이스를 알려 준다.

  즉, 리턴값이 있으면 그 리턴값의 테이터형을 컴파일러에게 알려 준다.

  또한 매개변수의 개수와 각 매개변수의 데이터형을 컴파일러에게 알려 준다.

  ```cpp
  double cube(double x);
  ```

  > 함수 원형은 cube()가 double형 매개변수를 가진다는 사실을 컴파일러에게 알려 준다. 프로그램이 cube()에 매개변수를 제공하는데 실패하면, 컴파일러는 함수 원형에 근거하여 에러를 검출한다.
  
  > cube() 함수는 계산을 끝냈을 때 리턴값을 어떤 지정된 위치에 넣는다. 호출한 함수가 그 위치에서 값을 꺼내온다. cube()가 double형이라는 것을 함수 원형이 컴파일러에게 알려 주므로  컴파일러는 그 위치에서 몇 바이트를 꺼내고, 어떻게 처리해야하는지 알고 있다.
  
  **함수 원형의 구문 규칙**

  함수 원형은 하나의 구문이기에 세미콜론으로 끝나야 한다.

  함수 원형은 함수 정의 부분에서 함수 머리 부분을 따다가 끝에 세미콜론만 붙이면 된다.

  ```cpp
  double cube(double x)
  {
    return x * x * x;
  }
  ```

  이면

  ```cpp
  double cube(double x);  //함수 머리에 ;을 추가
  ```

  이런 식으로 말이다.

  변수 이름(x)은 생략 가능하다.

  **함수 원형이 사용자를 위해 하는 일**

  > 컴파일러가 함수의 리턴값을 바르게 처리한다.
  
  > 사용자가 정확한 개수의 매개변수를 사용했는지 컴파일러가 검사한다.
  
  > 사용자가 정확한 데이터형의 매개벼수를 사용했는지 컴파일러가 검사한다. 사용자가 정확한 데이터형을 사용하지 않았다면, 컴파일러가 정확한 데이터형으로 변환한다.
  
  
## 07.2 함수 매개변수와 값으로 전달하기

일반적으로 C++는 함수 매개변수를 값으로 전달한다.

즉, 매개변수의 수치 값을 함수에 전달한다.

이때 전달되는 값은 새로운 변수에 대입된다.

```cpp
double volume = cube(side);
```

side에 5값을 사용하면 

```cpp
double cube(double x)
```
이 함수가 호출되면 x라는 새로운 double형 변수가 생성되고 거기에 5라는 값이 대입된다.

* 여러 개의 매개변수

  함수는 하나 이상의 매개변수를 가질 수 있고 함수 호출에서 매개변수들은 콤마로 분리한다.


## 07.3 함수와 배열

**포인터와 배열을 처리하는 함수**

C와 마찬가지로 C++도 대부분의 상황에서 배열 이름을 포인터처럼 사용한다.

```cpp
cookie == &cookie[0]  // 배열 이름은 첫 번째 원소의 주소이다
```

```cpp
int sum_arr(int arr[], int n)
{
  ...
}
```

위 코드에서 sum_arr() 함수는 배열의 첫 번째 원소의 주소를 전달 받는다.

* 배열을 매개변수로 사용하는 것의 의미

  배열의 실제 내용을 전달하는 것이 아닌 배열의 주소, 데이터형, 배열 원소의 개수를 함수에 전달하는 것이다.


* 배열을 처리하는 함수에 대한 보충

  **배열 채우기**

  배열 이름을 매개변수로 사용하는 함수는 배열의 복사본이 아닌 원본에 접근하기에 그 함수를 호출해 배열의 원소에 값을 대입할 수 있다.

  이때 그 함수의 매개변수 중 하나는 값으로 채우고자 하는 배열의 이름이어야 한다.

  ```cpp
  int fill_array(double ar[], int limit)
  {
    using namespace std;
    double temp;
    int i;
    for (i = 0; i < limit; i++)
    {
      cout << (i + 1) << "번 부동산의 가격: ";
      cin >> temp;
      if (!cin)
      {
        cin.clear();
        while (cin.get() != '\n')
          continue;
        cout << "입력 불량; 입력 과정을 끝내겠습니다.\n";
        break;
      }
      else if (temp < 0)
        break;
      ar[i] = temp;
    }
    return 0;
  }
  ```

  **배열의 내용 출력과 const로 보호하기**

  배열 이름과 값이 채워진 원소의 개수를 함수에 전달하면 함수는 루프를 사용해 각 원소를 출력한다.

  그러나 이때 함수의 목적이 데이터를 변경하는 것이 아니라면, 데이터가 변경되지 않도록 보호해야한다.

  배열을 사용하는 함수는 원본을 대상으로 작업하므로 const 키워드를 형식 매개변수를 선언할 때 사용하여 배열의 값이 변경되지 않도록 한다.

  ```cpp
  void show_array(const double ar[], int n);
  ```

  **배열의 수정**

  이 예제에서는 배열을 대상으로 수행할 세 번째 동작은 동일한 재평가율을 각각의 원소에 곱하는 것이다.

  재평가율, 배열 이름, 원소의 개수를 함수에 매개변수로 전달해야 한다.

  리턴값은 필요 없으므로 이 함수는 다음과 같다.

  ```cpp
  void revalue(double r, double ar[], int n)
  {
    for (int i = 0; i < n; i++)
      ar[i] *= r;
  }
  ```


* 배열의 범위를 사용하는 함수

  필요한 정보를 함수에 전달하는 하나의 방법은 원소들의 범위를 지정하는 것이다.

  두 개의 포인터 즉, 배열의 시작을 지시하는 포인터와 배열릐 끝을 지시하는 포인터를 전달하여 이루어진다.

  ```cpp
  double elbuod[20];
  ```

  두 개의 포인터 elbuod와 elvbuod + 20이 배열의 범위를 지정한다.

  배열의 이름인 elbuod는 첫 번째 원소, elboud + 19는 마지막 원소를 지시하느모 elboud + 20은 마지막 원소의 바로 다음을 지시한다.


* 포인터와 const

  포인터에서 const 키워드는 두 가지 방법으로 사용된다.

  > 상수 객체를 지시하는 포인터를 만드는 것. 상수 객체를 지시하는 포인터를 사용해 그 포인터가 지시하는 값은 변경할 수 없음.
  
  > 포인터 자신을 상수로 만드는 것. 상수 포인터를 사용해 그 포인터가 지시하는 장소를 변경할 수 없음.
  
  ```cpp
  int age = 39;
  const int * pt = &age;
  ```
  
  ```cpp
  *pt = 20;    // pt는 const int를 지시하고 있으므로 사용할 수 없다
  age = 20;    // age는 const로 선언되지 않았기 때문에 사용할 수 있다
  ```

  ```cpp
  const float g_earth = 9.80;
  const float *pe = &g_earth;    // 가능
  
  const float g_moon = 9.80;
  float *pm = &g_moon;    // 불가능
  ```


## 07.4 함수와 2차원 배열

배열 이름에 해당하는 형식 매개변수는 포인터이다.

```cpp
int data[3][4] = { {1,2,3,4}, {9,8,7,6}, {2,4,6,8} };
int total = sum(data, 3);
```

data는 세 개의 원소를 가진 배열의 이름이다

첫 번째 원소는 4개의 int값을 가지고 있는 배열이다.

따라서 data의 데이터형은 4개의 int값을 가진 배열을 지시하는 포인터다.

그래서 함수 원형은 다음과 같을 것이다.

```cpp
int sum(int (*ar2)[4], int size);
```


## 07.5 함수와 C 스타일의 문자열

C 스타일의 문자열은 널 문자로 끝나는 연속된 문자들이다.

* C 스타일의 문자열을 매개변수로 사용하는 함수

  함수의 매개 변수로 문자열을 전달해야 한다고 하면 문자열을 나타내는 방법은 다음 세 가지가 있다.

  > char형의 배열
  
  > 큰따옴표로 묶은 문자열 상수(문자열 리터럴)
  
  > 문자열의 주소로 설전된 char형을 지시하는 포인터
  
  세 가지 모두 char형을 지시하는 포이터이므로 문자열 처리 함수에 매개변수로 사용할 수 있다.

  ```cpp
  char ghost[15] = "galloping";
  char * str = "galumphing";
  int n1 = strlen(ghost);        // ghost는 &ghost[0]이다.
  int n2 = strlen(str);          // char형을 지시하는 포인터
  int n3 = strlen("gamboling");  // 문자열의 주소
  ```

  사실 문자열을 전달하는 것이 아닌 문자열을 구성하는 첫 문자의 주소를 전달하는 것이다.


* C 스타일 문자열을 리턴하는 함수

  문자열을 리턴하는 함수를 작성하고 싶을 때 문자열 자체를 리턴하는 것보다 문자열의 주소를 리턴하는 것이 더 효율적이다.

  ```cpp
  char * buildstr(char c, int n)
  {
    char * pstr = new char[n + 1];
    pstr[n] = '\0';
    while (n-- > 0)
      pstr[n] = c;
    return pstr;
  }
  ```

  문자열의 첫 문자의 주소를 리턴한다.


## 07.6 함수와 구조체

구조체 변수와 배열은 여러 개의 항목을 한 군데 모아서 저장한다는 점이 비슷하지만 구조체 변수는 기본적이며 단일한 값을 가지는 보통의 변수처럼 행동한다.

구조체 변수는 보통의 변수처럼 함수에 값으로 전달할 수 있고 구조체의 원본이 아닌 복사본을 대상으로 작업한다.

* 구조체의 전달과 리턴

  구조체를 값으로 전달하는 것은 구조체의 크기가 비교적 작은 경우일 때가 좋다.

  소요시간을 나타내는 구조체와 소요시간 구조체 두 개를 매개변수로 받아 그들의 함을 나타내는 구조체를 리턴하는 함수를 살펴보자

  ```cpp
  struct travel_time
  {
    int hours;
    int mins;
  };
  ```
  
  ```cpp
  travel_time sum(travel_time t1, travel_time t2);
  ```

  sum() 함수의 리턴값은 travel_time형이어야 하고 두 매개 변수도 travel_time형이어야 한다.


* 구조체 주소의 전달

  구조체 전체를 전달하는 대신에 주소만 함수에 전달하여 공간과 시간을 절약하고 싶다면 구조체를 지시하는 포인터를 사용하도록 해야한다.

  > 함수를 호출할 때 구조체 대신에 구조체의 주소를 전달한다.
  
  > 구조체를 지시하는 포인터를 형식 매개변수로 선언한다. 함수가 구조체를 변경하면 안되므로 const 키워드를 사용한다.
  
  ```cpp
  void show_polar(const polar * pda)
  ```
  
  > 형식 매개변수가 구조체가 아니라 포인터이므로 멤버 연산자(.) 대신에 간접 멤버 연산자(->)를 사용한다.
  
  ```cpp
  cout << "거리 = " << pda->distance;
  ```


## 07.7 함수와 string 클래스 객체

```cpp
string list[SIZE];
```

string의 배열을 만든다.

list의 각 원소는 string 객체이고 다음과 같이 사용될 수 있다.

```cpp
getline(cin, list[i])
```


## 07.8 함수와 array 객체

C++에서 클래스 객체는 구조체에 기반을 두고 있다.

1년간 사계절의 각각에 대하여 비용 숫자를 지니기 위한 array 객체를 하나 가지고 있다고 가정해보자

```cpp
std :: array<double, 4> expenses;
```

expenses에 저장된 내용을 표시하기 위한 함수를 원한다면 expenses 값을 함수로 보내야한다.

```cpp
show (expenses);
```

만약 expenses 개체를 수정하는 함수를 원한다면 객체의 주소를 함수로 보내야 한다.

```cpp
fill(&expenses);
```


## 07.9 재귀 호출

C++ 함수는 자기 자신을 호출할 수 있는 능력(재귀 호출)을 가지고 있다. (C와 다르게 C++은 main() 함수가 재귀 호출하는 것은 허용하지 않는다.)

* 단일 재귀 호출

  재귀 함수가 자신을 호출하면 새로 호출되는 함수도 다시 자신을 호출하게 되므로 호출의 연쇄를 끝내는 것이 없다면 재귀 호출은 끝없이 반복될 것이다.

  호출의 연쇄를 끝내기 위해 일반적으로 재귀 호출 부분을 if 구문의 일부로 만드는 것이다.

  ```cpp
  void recurs(argumentlist)
  {
      statements1
      if (test)
        recurs(arguments)
      statements2
  }
  ```

  if 구문이 참인 동안 각각의 recurs() 함수 호출은 statements1 부분만 수행하고 statements2 부분은 수행을 유보한다.


* 다중 재귀 호출

  재귀 호출은 하나의 작업을 서로 비슷한 두 개의 작은 작업으로 반복적으로 분할해 가면서 처리해야 하는 상황에서 특별히 유용하다.

  이러한 재귀적인 접근을 분할 정복 전략이라고 한다.

  ```cpp
  void subdivide(char ar[], int low, int high, int level)
  {
    if (level == 0)
      return;
    int mid = (high + low) / 2;
    ar[mid] = '|';
    subdivide(ar, low, mid, level - 1);
    subdivide(ar, mid, high, level - 1);
  }
  ```


## 07.10 함수를 지시하는 포인터

데이터 항목과 마찬가지로 함수도 주소를 가지고 있다.

함수의 주소는 그 함수에 해당하는 기계어 코드가 저장되어 있는 메모리 블록의 시작 주소이다.

* 함수 포인터의 기초

  주어진 행 수 만큼 프로그램 코드를 작성하는 데 걸리는 시간을 평가하는 estimate() 라는 함수를 설계하고 여러 명의 프로그래머가 사용할 것이라고 가정하자.

  프로그래머 각자가 원하는 특별한 알고리즘 함수의 주소를 estimate() 함수에 전달해야 한다.

  > 함수의 주소를 얻는다.

  > 함수를 지시하는 포인터를 선언한다.
  
  > 함수를 지시하는 포인터를 사용해 그 함수를 호출한다.
  
  **함수 주소 얻기**

  함수 주소를 얻는 방법은 뒤에 붙은 괄호를 빼고 함수 이름만 사용하면 된다.

  ```cpp
  process(think);    // process()에 think()의 주소를 전달
  thought(think());  // thought()에 think()의 리턴값을 전달
  ```

  **함수를 지시하는 포인터 선언**

  포인터가 지시하는 함수의 데이터형을 지정해야한다.

  ```cpp
  double pam(int)    // 함수 원형
  ```

  ```cpp
  double (*pf) (int);    // pf는 하나의 int를 매개 변수로 취하고
                         // double형을 리턴하는 함수를 지시한다.
  ```

  **포인터를 사용하여 함수 불러내기**

  ```cpp
  double pam(int);
  double (*pf) (int);
  pf = pam;    // pf는 pam() 함수를 지시
  double x = pam(4);    // 함수 이름을 사용한 pam() 함수의 호출
  double y = (*pf)(5);    // 포인터 pf를 사용한 pam() 함수의 호출
  double y = pf(5);    // 포인터 pf 사용한 pam() 함수의 호출
  ```


# 08장 함수의 활용

이 장에서는 C에는 없고 C++에 새로 추가된 기능들을 주로 살펴본다

## 08.1 C++ 인라인(inline) 함수

인라인 함수는 프로그램의 실행 속도를 높이기 위해 C++에 새로 보강된 것이다.

일반적인 함수의 호출은 앞뒤로 점프를 수행하고, 점프할 위치를 기억하려면 함수를 사용하는 데 시간이 많이 걸린다.

인라인 함수에서는 컴파일된 함수 코드가 프로그램의 다른 코드 안에 직접 삽입되어 있다.

하지만 메모리 사용측면에서는 인라인 함수가 더 불리하다.

호출될 때마다 함수의 사본을 프로그램의 코드 안에 호출된 만큼 삽입해야 하기 때문이다.

함수코드를 수행하는 데 걸리는 시간이 매우 짧은 경우에만 사용하는 것이 좋다.

인라인 함수를 사용하려면 다음 두 가지 작업 중에 적어도 한가지를 반드시 해야 한다.

> 함수 선언 앞에 inline 키워드를 붙인다.

> 함수 정의 앞에 inline 키워드를 붙인다.


## 08.2 참조 변수

참조는 미리 정의된 어떤 변수의 실제 이름 대신 쓸 수 있는 대용 이름이다.

* 참조 변수의 생성

  변변수의 주소를 나타내기 위해 & 기호를 사용하는데 C++은 & 기호에 참조 선언을 나타내게 했다.

  ```cpp
  int rats;
  int & rodents = rats;    // rodents를 rats의 대용 이름으로 만든다
  ```

  여기서 &는 주소 연산자가 아닌 데이터형 식별자의 일부로 사용된 것이다.

  참조 선언은 rats와 rodents를 서로 바꿔 사용할 수 있게 하는데 둘은 모두 같은 값과 같은 메모리 위치를 참조한다.


* 함수 매개변수로서의 참조

  참조는 주로 함수의 매개변수로 사용된다.

  ```cpp
  void sneezy(int x);
  int main()
  {
    int times = 20;  // times라는 변수를 만들고 값 20을 대입
    sneezy(times);
    ...
  }

  void sneezy(int x)   // x라는 변수를 만들고 전달된 값 20을 대입
  {
    ...
  }
  ```

  ```cpp
  void sneezy(int &x)  // x를 times의 대용 이름으로 만듬
  {
    ...
  }
  ```

* 참조의 특성

  ```cpp
  double cube(double a)
  {
    a *= a * a;
    return a;
  }
  ```

  ```cpp
  double refcube(double &ra)
  {
    ra *= ra * ra;
    return ra;
  }
  ```

  x가 3.0일 때 두 함수 모두 27의 값을 리턴한다.

  하지만 main()함수에서의 x값은 cube(x)에 의해서는 바뀌지 않지만 refcube(x)에 의해 27로 변경된다.

  **임시 변수, 참조 매개변수, const**

  C++는 실제 매개변수와 참조 매개변수가 일치하지 않을 때 임시 변수를 생성할 수 있다.

  최근의 C++는 매개변수가 const 참조일 경우만 허용한다.

  참조 매개변수가 const일 경우 컴파일러는 다음과 같은 두 가지 상황에서 임시 변수를 생성한다.

  > 실제 매개변수가 올바른 데이터형이지만 lvalue가 아닐 때
  
  > 실제 매개변수가 잘못된 데이터형이지만 올바른 데이터형으로 변환 할 수 있을 때
  
  lavaue 매개변수는 참조가 가능한 데이터 객체다. 예를 들어 변수, 배열의 원소, 구조체의 멤버, 참조 또는 역참조 포인터를 말한다.

  일반 상수나 여러 개의 항으로 이루어진 표현식은 lvalue가 아니다.

  ```cpp
  double refcube(double &ra)
  {
    ra *= ra * ra;
    return ra;
  }
  ```

  ```cpp
  double side = 3.0;
  long edge = 5L;
  double c4 = recube(edge);    // 데이터형이 잘못되었기에 ra는 임시 변수
  double c5 = recube(7.0);    // 상수이기에 ra는 임시 변수
  double c6 = recube(side + 10.0); // 여러 개의 항으로 이루어진 표현식이기에 ra는 임시 변수
  ```

  형식 매개변수가 const 참조로 되어 있는 함수는, 데이터형이 일치하지 않는 실제 매개변수를 전달 받았을 때, 정보를 값으로 전달받는 전통적인 방식을 따른다.

  즉, 임시 변수를 사용하므로 원본 데이터를 변경하지 않는다.

* 구조체에 대한 참조

  구조체에 대한 참조를 사용하는 방법은 구조체 매개변수를 선언할 때 참조 연산자 &를 앞에 붙이면 된다.

  ```cpp
  struct free_throws
  {
    std::string name;
    int made;
    int attemps;
    float percent;
  };
  ```

  위와 같은 형에 대하여 참조를 사용하는 함수는 다음과 같이 원형을 지닐 수 있다.

  ```cpp
  void set_pc(free_throws & ft);    // 구조체에 대하여 참조를 사용
  ```

  이 함수가 구조체를 변경하지 않으면 const를 사용할 수 있다.
  
  ```cpp
  void set_pc(const free_throws & ft);    // 구조체에 대하여 변경을 허용하지 않음
  ```

  **참조를 리턴할 때 주의할 점**

  참조가 종료할 때 수명이 함께 끝나는 메모리 위치에 대한 참조를 리턴하지 않도록 조심해야 한다.

  ```cpp
  const free_throws & clone2(free_throws & ft)
  {
    free_throws newguy;    // 큰 에러를 일으키는 첫걸음
    newguy = ft;    // 정보를 복사
    return newguy;    // 복사본에 대한 팜조를 리턴
  }
  ```

  이 코드는 함수가 종료할 때 함께 사라지는 임시 변수(newguy)에 대한 참조를 리턴하는 것이므로 이는 피해야한다.


* 클래스 객체와 참조

  일반적으로 C++는 클래스 객체를 함수에 전달할 때 참조를 사용한다.

  예를 들면 string, ostream, istream, ofstream, ifstream 클래스의 객체를 매개변수로 취하는 함수들에 참조 매개변수를 사용할 있다.

  아래 같은 경우를 주의해야 한다.
  
  ```cpp
  const string & version2(string & s1, const string & s2)
  {
    s1 = s2 + s1 + s2;
  // 함수에 전달된 참조를 리턴해 안전함
    return s1;
  }

  const string & version3(string & s1, const string & s2)
  {
    string temp;
  
    temp = s2 + s1 + s2;
  // 지역 변수에 대한 참조를 리턴해 안전하지 않음
    return temp;
  }
  ```


* 참조 매개변수는 언제 사용하는가?

  참조 매개변수를 사용하는 주된 이유는 다음 두 가지이다.

  > 호출 함수에 있는 데이터 객체의 변경을 허용하기 위해
  
  > 전체 데이터 객체 대신에 참조를 전달하여 프로그램의 속도를 높이기 위해
  
  두 번째 이유는 구조체나 클래스 객체와 같이 덩치 큰 데이터 객체를 다룰 때 중요하다.

  함수가 전달된 데이터를 변경하지 않고 사용만 하는 경우 :

  > 데이터 객체가 기본 데이터 형이나 작은 구조체라면 값으로 전달
  
  > 데이터 객체가 배열이라면 포인터를 사용한다. 포인터를 const를 지시하는 포인터로 만든다.
  
  > 데이터 객체가 덩치 큰 구조체면 const 포인터나 const 참조를 사용해 프로그램의 속도를 높인다.
  
  > 데이터 객체가 클래스 객체라면 const 참조를 사용한다. 클래스 객체 매개변수의 전달은 참조로 전달하는 것이 표준이다.
  
  함수가 호출 함수의 데이터를 변경하는 경우 :

  > 데이터 객체가 기본 데이터형이면 포인터를 사용한다.
  
  > 데이터 객체가 배열이면 유일한 선택은 포인터를 사용하는 것이다.
  
  > 데이터 객체가 구조체이면 참조 또는 포인터를 사용한다.
  
  > 데이터 객체가 클래스 객체면 참조를 사용한다.
  

## 08.3 디폴트 매개변수

디폴트 매개변수는 함수 호출에서 실제 매개변수를 생략했을 경우에 실제 매개변수 대신 사용되는 값이다.

예를 들어 void wow(int n)에서 n이 1로 내정되도록 디폴트 값을 지정했다.

디폴트 값은 함수원형으로 설정 가능하다.

```cpp
char * left(const char * str, int n = 1);
```


## 08.4 함수 오버로딩

함수 오버로딩이라고 부르는 함수의 다형은 서로 다른 여러 개의 함수가 하나의 이름을 공유하는 것이다.

시그내처는 매개변수의 개수와 종류가 다르다.

```cpp
void print(const char * str, int width);  // #1
void print(double d, int width);          // #2
void print(long l, int width);            // #3
void print(int i, int width);             // #4
void print(const char *str);              // #5
```

```
print("Pancakes", 15);  // #1 사용
print("Syrup");         // #5 사용
print(1999.0, 10);      // #2 사용
print(1999, 12);        // #4 사용
print(1999L, 15);       // #3 사용
```

* 함수 오버로딩은 언제 사용하는가?

  함수 오버로딩은 서로 다른 데이터형을 대상으로 하지만 기본적으로 같은 작업을 수행하는 함수들에만 사용해야 한다.

  서로 다른 데이터형의 매개변수를 요구하고 디폴트 매개변수가 소용 없을 때에 함수 오버로딩을 사용해야 한다.


## 08.5 함수 템플릿

함수 탬플릿은 함수의 일반화 서술이다.

즉, 함수의 템플릿은 int형이나 double형과 같은 구체적인 데이터형을 포괄할 수 있는 일반형으로 함수를 정의한다.

어떤 데이터형을 템플릿에 매개변수로 전달하면 컴파일러가 데이터형에 맞는 함수를 생성한다.

예를 들어 두 변수의 값을 교환하는 템플릿을 다음과 같이 설정할 수 있다.

```cpp
template <class Any>
void Swap(Any &a, Any &b)
{
  Any temp;
  temp = a;
  a = b;
  b = temp;
}
```

첫 번째 행은 템플릿을 설정하고 임의 데이터형의 이름을 Any로 정한다는 뜻이다.

키워드 template과 class(typename도 가능)을 반드시 사용해야한다.

* 템플릿의 오버로딩

  모든 데이터형이 항상 같은 알고리즘을 사용하지 않기에 템플릿 정의를 오버로딩 할 수 있다.

  템플릿을 오버로딩할 때에도 확실하게 구분되는 시그내처를 사용해야 한다.

  예를들어 위의 코드를 이용해 두 배열의 원소를 교환하는 새로운 템플릿을 추가하면

  (T &, T &)라는 시그내처가 아닌 (T [], T [], int)라는 시그내처를 사용한다. 마지막 매개변수는 일반형이 아닌 구체형이다.


* 명시적 특수화

  다음과 같은 구조체를 정의한다고 가정하자.

  ```cpp
  struct job
  {
    char name[40];
    double salary;
    int floor;
  };
  ```

  이러한 구조체 두 개를 만들고 두 구조체의 내용을 교환하려고 한다.

  원본 템플릿은 다음과 같은 코드를 사용해 내용을 교환한다.

  ```cpp
  temp = a;
  a = b;
  b = temp;
  ```

  만약 sallary와 floor 멤버만 교환하고 name 멤버는 그대로 두고 싶다면 템플릿 오버로딩을 사용할 수 없다.

  그러나 명시적 특수화라는 특수화된 함수 정의를 필요한 코드와 함께 제공할 수 있다.

  컴파일러가 함수 호출에 정확히 대응하는 특수화된 정의를 발견하면, 템플릿을 찾지 않고 그 정의를 사용한다.

  **3세대 특수화(ISO/ANSI C++ 표준)**

  > 함수 이름이 하나 주어지면, 사용자는 템플릿이 아닌 함수, 템플릿 함수, 명시적 특수화 템플릿 함수를 가질 수 있다. 또 이 모든 것들의 오버로딩 버전도 가질 수 있다.
  
  > 명시적 특수화를 하기 위한 원형과 정의 앞에 template <>가 와야한다. 그리고 그 특수형의 이름을 서술해야 한다.
  
  > 특수화는 템플릿을 무시하고, 템플릿이 아닌 함수는 특수화와 템플릿 둘 다를 무시한다.
  
  다음은 job형 구조체를 교환하는 세가지 함수형이다.

  ```cpp
  // 템플릿이 아닌 함수 원형
  void Swap(job &, job &);

  // 템플릿 원형
  template <typename T>
  void Swap(T &, T &);

  // job형을 위한 명시적 특수화
  template <> void Swap<job>(job &, job &);
  ```

  이 원형들이 공존할 때 컴파일러는 명시적 특수화 버전이나 템플릿 버전보다 아닌 버전을 선택한다. 그리고 템플릿 버전보다는 명시적 특수화 버전을 선택한다.

  예를 들어 다음과 같은 코드에서 Swap()에 대한 첫 번째 호출은 일반 템플릿을 사용한다 두 번째 호출은 job형에 기초하는 명시적 특수화를 사용한다.

  ```cpp
  ...
  template <Class T>  // 템플릿
  void Swap(T &, T &);

  // job형에 대한 명시적 특수화
  template <> void Swap<job>(job &, job &);
  int main()
  {
    double u, v;
    ...
    Swap(u,v);   // 템플릿 사용
    job a, b;
    ...
    Swap(a, b);  // void Swap<job>(job &, job &) 사용
  }
  ```

  이것이 job를 위한 특수화라는 것을 함수 매개변수의 데이터형이 알려 주기 때문에 <job>은 생략가능하다.

  **구체화와 특수화**

  템플릿을 더 잘 이해하기 위해 구체화와 특수화라는 용어를 살펴보자.

  컴파일러가 특정 데이터형에 맞는 함수 정의를 생성하기 위해 템플릿을 사용할 때 그 결과를 템플릿의 구체화라고 한다.

  프로그램이 무슨 데이터형을 요구하는 함수를 사용하는지를 컴파일러에게 알림으로써, 그에 맞는 함수 정의를 만들 필요가 있다는 것을 컴파일러가 암시적으로 인식하는 것을 **암시적 구체화**라고 한다.

  컴파일러가 Swap<int\>()와 같은 특정 구체화를 생성하도록 사용자가 직접 지시할 수 있다는 것은 **명시적 구체화**라고 한다.

  **명시적 특수화**선언은 키워드 template 뒤에 <>를 가지는 반면, 명시적 구체화는 <>를 생략한다.

  암시적 구체화, 명시적 구체화, 명시적 특수화 모두 특수화라고 한다. 이드르이 공통점은 이들이 일반화 서술을 나타내는 함수 정의가 아닌 구체적인 데이터형을 사용하는 함수 정의를 나타낸다는 것이다.


* 컴파일러는 어느 함수를 선택할까?

  함수 오버로딩, 함수 템플릿, 함수 템플릿 오버로딩 등이 있기 때문에 어떤 함수 호출에 대해 매개 변수가 여러 개일 때 어떤 함수 정의를 사용할 것인지 C++은 전략을 가지고 있다.

  이 전략을 오버로딩 분석이라 한다.

  > 1단계: 후보 함수들의 목록을 만든다. 이들은 호출된 함수와 이름이 동일한 함수와 함수 템플릿들이다.
  >
  > 2단계: 매개변수의 개수가 일치하는 함수들을 남기고 이들에 대해 암시적 변환 절차가 이루어진다.
  >
  > 3단계: 가장 정당한 함수가 있으면 그 함수를 사용하고 없으면 함수 호출은 에러가 된다.
  

* 템플릿 함수의 발전

  **그 타입은 무엇인가?**

  프로그래머가 템플릿 함수를 쓰려고 할 때 한 가지 문제점은 C++98에서 선언을 할 때에 어떤 타입에 사용해야 하는지 알아내는 방법이 항상 가능한 것은 아니라는 점이다.

  **decltype 키워드(C++)**

  C++11 솔루션은 새로운 키워드 decltype이다.

  ```cpp
  int x;
  decltype(x) y;  // x와 동일한 타입의 y를 만들어라
  ```

## 제네릭 프로그래밍의 보충

**간단한 정의** : 타입에 관계없이 동작하는 "일반적인" 코드를 작성하는 방법

Ex) 여러가지 덧셈을 수행하는 함수를 작성할 때 add(int,int) / add(double,double) / add(Point,Point) 이것들을 한 번의 코드 작성으로 가능하게 하는 방법

**제네릭 프로그래밍의 구현 방법** : 매크로 사용(주의가 필요함), 함수/클래스 템플릿 사용

* 매크로를 사용한 제네릭 프로그래밍

  매크로(\#define) : 코드의 단순 대체(복붙)

  ```cpp
  #define PI 3.14259

  int main()
  {
    double a = PI * 2;
    double b = PI * 4;
  }
  ```

  위 코드를 실행하면 전처리기가 PI를 3.14159가 대체하게 전처리를 한다.

  ```cpp
  #include <iostream>
  
  int max(int a, int b)
  {
    return (a > b) ? a : b;
  }

  int main()
  {
    int x = 100;
    int y = 200;

    std::cout << max(x,y);
  }
  ```

  위 코드에서 max함수는 int형 데이터 밖에 처리를 하지 못한다. 다른 데이터형을 사용하려면 위에서 배운 오버 로딩할 수도 있지만, 매크로를 사용할 수 있다.

  ```cpp
  #include <iostream>

  #define MAX(a,b) ((a>b)?a:b)
  
  int main()
  {
    int x = 100;
    int y = 200;

    std::cout << max(x,y); // 전처리기를 통해 ((x>y)?x:y)와 같이 대체된다.

    double z = 1.234;
    double w = 3.456;

    std::cout << max(z,w); // 전처리기를 통해 ((z>w)?z:w)와 같이 대체된다.
  }
  ```

* 매크로를 사용할 때의 유의사항

  코드가 단순 대체됨에 유의해야 한다. 매크로문을 괄호로 감싸는 것이 안전하다.

  ```cpp
  #define SQUARE(a) a*a
  result = SQUARE(5);  //25
  result = 5*5;  //25

  result = 100/SQUARE(5); // 4가 나오기를 기대하지만
  result = 100/5*5;  // 100이 나온다.
  ```

  매크로를 활용한 Generic Programming은 매크로를 활용하여 코드를 대체하는 것이기 때문에 주의가 필요하다.

* C++ 템플릿

  > "설계도 개념"
  
  > 함수 템플릿과 클래스 템플릿 구현을 지원

  > 어떤 데이터 타입이든 컴파일러가 적절한 함수/클래스를 설계도를 기반으로 생성함(C++의 경우 컴파일러가 생성하지만, 다른 언어는 런타임에 생성할 수 있음)
  
  > 템플릿을 이용해 생성하는 제너릭 프로그래밍 / 컴파일 동시에 생성하는 메타 프로그래밍


* 템플릿을 사용한 max 함수의 구현

  1. 타입명을 T로 대체
 
  2. T가 템플릿 인수라는 것을 명시
 
  ```cpp
  #include <iostream>
  
  template <typename T>  // or template <Class T>
                         // 무조건 T를 써야하는 것은 아니지만
                         // 많은 개발자들이 T를 우선적으로 사용
  T max(t a, T b)
  {
    return (a>b) ? a : b;
  }

  int main()
  {
    int a = 10;
    int b = 20;
    std::cout << max<int>(a,b);  // <\>에 타입 이름을 넣어줌
  }
  ```

  꺽세에다가 타입만 넣어주면 컴파일러가 타입에 맞는 함수를 설계도를 이용해 만들어준다.

  템플릿 코드만 존재할 때는 아무 함수도 생성되지 않는다.

  변수형을 생략 가능하기도 하다.

* 템플릿이 사용 가능한 경우

  클래스의 경우 필요한 연산자가 오버로딩이 되어있어야 템플릿 max함수 사용 가능하다.
  (max함수의 경우 \> 연산자의 정의가 되어있어야 함)


# 09장 메모리 모델과 이름 공간

## 09.1 분할 컴파일

파일들을 개별적으로 분할하여 컴파일한 후 하나의 최종 실행 프로그램으로 링크할 수 있다.

만약 하나의 파일을 수정했다면 그 수정 파일 하나만 다시 컴파일 해 이미 컴파일되어 있는 다른 파일들과 링크하면 된다.

규모가 큰 프로그램을 쉽게 관리할 수 있게 해준다.

* \#include 기능

  여러개의 파일에서 구조체 선언이 필요할 때 각각의 파일에 구조체 선언을 넣는 대신에 그것을 헤더 파일에 넣은 후 그 헤더 파일을 각각의 소스파일에 포함시킨다.

  원본 프로그램을 다음과 같은 세 부분으로 분할할 수 있다.

  > 구조체 선언과 그 구조체를 사용하는 함수들의 원형이 들어 있는 헤더 파일
  
  > 그 구조체에 관련된 함수들의 코드가 들어 있는 소스 코드 파일
  
  > 그 구조체에 관련된 함수들을 호출하는 코드가 들어 있는 코드 파일
  
  헤더 파일에는 다음과 같은 것들을 넣는다.

  > 함수 원형
  
  > \#define이나 const를 사용하여 정의하는 기호 상수
  
  > 구조체 선언

  > 클래스 선언

  > 인라인 함수

## 09.2 기억 존속 시간, 사용 범위, 링크

C++는 네 가지 유형으로 데이터를 저장하는데 이는 메모리에 데이터를 존속시키는 시간에서 차이가 난다.

> 자동 기억 존속 시간: 함수 정의 안에 선언된 변수는 **자동 기억 존속 시간**을 가진다.
> 그들은 프로그램 실행이 그들을 정의하고 있는 함수나 블록으로 들어갈때 생성, 떠날 때 해제된다.
> C++은 두 종류의 자동 변수를 가진다.

> 정적 기억 존속 시간: 함수 정의의 바깥에서 정의된 변수 또는 키워드 static을 사용해 정의된 변수는, **정적 기억 존속 시간**을 가진다.
> 프로그램이 실행되는 전체 시간 동안 존속한다.
> C++은 세 종류의 정적 변수를 가진다.

> 쓰레드 존속 시간: 멀티코어 프로세서란 여러 작업을 동시에 처리할 수 있는 CPU를 의미한다.
> 멀티코어 프로세서를 사용하여 연산 작업을 쓰레드 단위로 쪼개서 처리할 수 있다.

> 동적 기억 존속 시간: new 연산자를 사용하여 대입된 메모리는 delete 연산자로 해제되거나 프로그램이 종료될 때 까지 존속한다.
> 이 메모리는 **동적 기억 존속 시간**을 가진다.
> 때로는 이 메모리를 **자유 공간**이라고 부른다.

* 사용 범위와 링크

  > 사용 범위란 어떤 이름이 하나의 파일(혹은 번역 단위) 안에서 얼마나 널리 알려지는가를 나타낸다.

  > 링크란 서로 다른 번역 단위들이 이름을 공유하는 것을 말한다.

  > 외부링크를 가진 이름은 여러 파일을 공유할 수 있다.

  > 내부링크를 가진 이름은 한 파일 안에 있는 함수들만 공유할 수 있다.

  하나의 C++ 변수는 몇 가지 사용 범위 중 하나를 가질 수 있다.

  > 지역 사용 범위, 즉 블록 사용 범위를 가지는 변수는 그 변수를 정의한 블록 안에만 알려진다.

  > 파일 사용 범위, 즉 전역 사용 범위를 가지는 변수는 그것이 정의된 지점부터 파일 전체에 걸쳐 알려진다.

  > 함수 원형 사용 범위에 사용되는 이름은 매개변수 리스트를 둘러싸고 있는 괄호 안에만 알려진다.
  
  > 클래스 안에 선언된 멤버는 클래스 사용 범위를 가진다.

  > 어떤 이름공간 안에 선언된 변수는 이름 공간 사용 범위를 가진다.
  
  C++ 함수는 지역 사용 범위만은 가질 수 없다.

  (어떤 한수를 블록 안에서 정의할 수 없는데 다른 함수가 그 함수를 호출할 수 없게 되므로, 함수의 기능을 수행할 수 없기 때문이다.)


* 자동 변수

  함수 매개변수와 함수 안에서 선언된 변수는 기본적으로 자동 기억 존속 시간을 가진다.

  이들은 지역 사용 범위를 가지며 링크는 없다.

  ex) main() 안에 texas 변수를 선언하고 oil()이라는 함수 안에서 같은 이름으로 또 하나의 변수를 선언하면 서로 독립적이며 자신이 정의된 함수 안에만 알려지는 두 개의 texas 변수를 생성하는 것이 된다.

  **자동 변수의 초기화**

  자동 변수느 그 선언에 도달된 시점에서 값을 알 수 있다면 어떠한 표현식을 사용하더라도 초기화 할 수 있다.

  ```cpp
  int w;    // w의 값은 미확정
  int x = 5;    // 숫자 표현식으로 초기화
  int big = INT_MAX - 1;    // 상수 표현식으로 초기화
  int y = 2 * x;    // 이미 알려진 x의 값을 사용
  cin >> w;
  int z = 3 * w;    // w의 새로운 값을 사용한다.
  ```

  **자동 변수와 스택**

  C++이 자동 변수를 구현할 때 일반적인 방법은 메모리의 일부를 예약해 두고변수들의 생성과 소멸을 스택으로 관리하는 것이다.

  프로그램은 두 개의 포인터를 이용하여 스택을 관리한다.

  한 포인터는 스택으로 예약한 메모리의 시작 위치인 스택의 바닥을 지시하고 다른 한 포인터는 다음 번 데이터의 저장을 위해 비어 있는 메모리 위치인 스택의 꼭대기를 지시한다.

  **레지스터 변수**

  본래 C는 register 키워드를 제공해 컴파일러가 CPU 레지스터를 사용해서 자동 변수를 저장할 것을 제안한다.

  ```cpp
  register int count_fast;    //register 변수를 요청한다.
  ```

  변수에 더욱 빨리 접근하는 것을 허용하기 위함이다.


* 정적 변수

  C++는 세 가지 유형의 링크(외부 링크, 내부 링크, 링크 없음)를 가지는 정적 변수를 제공한다.

  세 가지 유형 모두 프로그램이 실행되는 전체 시간동안 존속한다.

  정적 변수를 명시적으로 초기화하지 않으면 컴파일러는 그것들을 모두 0으로 초기화한다.

  **정적 변수 초기화**

  정적 변수는 제로 초기화될 수 있고 상수 표현 초기화될 수 있으며 동적 초기화될 수 있다.

  제로 초기화는 변수를 제로에 세팅시키는 것이다.

  제로 초기화와 상수 표현 초기화를 합해서 정적 초기화라 부른다. (컴파일러가 파일을 처리할 때 변수가 초기화된다는 의미)

  동적 초기화는 그 변수가 이후에 초기화된다는 것이다.


* 정적 존속 시간, 외부 링크

  외부 연계성을 지닌 변수는 외부 변수로 불린다.

  외부 변수는 정적 저장 기간과 파일 범위를 지니며, 외부에서 정의되기 때문에 다른 외부 함수와 연계된다.

  **단일 정의 원칙**

  한편으로는 외부 변수가 그 변수를 사용하는 모든 각각의 파일에서 선언되어야 할 것이다.

  다른 한편으로는 C++에는 하나의 변수에 대해 하나의 정의를 부여하는 **단일 정의 원칙**을 명시하고 있다.

  이러한 요구 사항을 충족시키기 위해 C++은 두 종류의 변수 선언을 한다

  > 첫째 선언을 정의하는 것 또는 단순하게 정의로 대입되는 변수에 대하여 저장소를 제공한다.

  > 둘째 참조 선언 혹은 단순히 선언하는 것인데 이경우엔 기존의 변수를 의미하므로 저장소를 생성하지 않는다.
  > 참조 선언은 extern이라는 키워드를 사용하고 초기화를 제공하지 않는다.
  
  ```cpp
  double up;    // 정의, up는 0
  extern int blem;    // blem은 다른 지역에서 정의된다.
  extern char gr = 'z';    // 초기화되었으므로 정의다.
  ```


* 정적 존속 시간, 내부 링크

  파일 사용 범위가 있는 변수에 static 제한자를 적용하면 내부 링크를 부여하게 된다.

  내부 링크 변수는 그 변수를 포함하고 있는 파일에서만 사용할 수 있지만 외부 링크 변수는 다른 파일에서도 사용이 가능하다.


* 정적 기억 존속 시간, 링크 없음

  링크가 없는 파일 사용 범위의 변수는 블록 안에서 정의되는 변수에 static 제한자를 적용하여 만든다.

  블록 안에서 static을 사용하면 static이 지역 변수를 정적 기억 존속 시간을 갖게 만든다.


* 제한자

  기억 공간 제한자와 cv제한자라고 부르는 몇가지 C++ 키워드가 기억 공간에 대해서 추가 정보를 제공한다.

  |기억 공간 제한자의 목록|
  |---|
  |auto(C++11에서는 빠짐)|
  |register|
  |static|
  |extern|
  |thread_local(C++에서 추가됨)|
  |mutable|

  하나의 선언에는 제한자 하나만 사용할 수 있는데 thread_local만 static 또는 extern과 함꼐 사용 가능하다.

  auto 키워드는 어떤 변수가 자동 변수라는 선언에 사용되었다.(C++11에서 auto는 자동 형변환에 사용된다.)

  register 키워드는 레지스터 기억 공간을 지정하는 선언에 사용된다.

  static 키워드는 파일 범위 선언에 사용될 때 내부 링크를 나타내며 지역 선언에 사용될 때는 지역 변수를 위한 정적 기억 존속 시간을 가리킨다.

  extern 키워드는 참조 선언을 나타낸다. 그 선언은 다른 곳에 이미 정의되어 있는 변수를 참조한다.

  thread_local 키워드는 변수의 존속 시간이 변수를 포함하는 쓰레드의 존속 시간이다. 정적 변수의 존속 시간은 프로그램의 존속 시간과 같지만, tread_local 변수는 쓰레드 존속 시간과 같다.

  mutable 키워드는 const 관점에서 설명할 수 있으므로 cv-제한자를 먼저 살펴보면

  |Cv- 제한자|
  |---|
  |const|
  |volatile|

  const는 메모리가 일단 초기화된 후에는 프로그램이 그 메모리를 변경할 수 없다는 뜻이다.

  volatile 키워드는 프로그램 코드가 변경하지 않더라도 특정 메모리 위치에 있는 값이 변경될 수 있다는 것을 나타낸다.

  EX) 직렬 포트로 들어오는 시간이나 정보가 저장되어 있는 하드웨어 위치를 지시하는 포인터를 가질 경우 프로그램이 아니라 하드웨어가 그 메모리의 내용을 변경한다.

  **mutable**

  mutable은 특정 구조체(혹은 클래스)가 const로 선언되어 있더라도 그 구조체의 특정 멤버를 변경할 수 있음을 나타내는 데 사용한다.

  ```cpp
  struct data
  {
    char name[30];
    mutable int accesses;
    ...
  };
  const data veep = {"Claybourne Clodde", 0, ...};
  strcpy(veep.name, "Joye Joux");    // 허용 안함
  veep.accesses+++    // 허용함
  ```

  **const에 대한 보충**

  C++에서는 const 제한자가 디폴트 기억 공간을 바꾼다. 전역 변수는 외부 링크를 갖도록 디폴트로 내정되어 있지만,

  const 전역 변수는 내부 링크를 갖도록 디폴트로 내정된다.


* 함수와 링크

  변수와 마찬가지로 함수도 리크 속성을 가진다.

  C++는 하나의 함수안에 다른 함수를 정의할 수 없다. 따라서 모든 함수는 자동적으로 정적 기억 존속 시간을 가진다.

  기본적으로 함수는 외부 링크를 가진다. 즉 여러 파일이 함수를 공유할 수 있다.


* 언어 링크

  언어 링크라는 또 다른 형태의 링크가 있다.

  C++ 컴파일러는 오버로딩된 함수들에 대해서 서로 다른 기호 이름을 생성하기 위해 이름 맹글링 또는 이름 장식 과정을 거친다.

  EX) C++ 컴파일러는 spiff(int)를 _spidd_i로, spiff(double, double)를 _spidd_d_d 변환할 수 있다.

  이러한 C++의 접근 방식을 C++ 언어 링크라 한다.


* 기억 공간 형식과 동적 대입

  변수에 메모리를 대입하기 위해 사용하는 다섯 가지 기억 공간 형식은 C++의 new 연산자에 의해 대입한 메모리에는 적용되지 않는다.

  이런 종류의 메모리를 동적 메모리라고 부른다.

  동적 메모리는 사용 범위나 링크 규칙에 의해서가 아닌 new와 delete를 언제 어떻게 사용하느냐에 달여 있다.


  **new 연산자를 이용한 초기화**

  int형, double형과 같은 변수를 생성하고 초기화하기 위한 저장 공간을 원한다면 다음과 같이 괄호를 이용해 초기 값을 설정할 수 있다.

  ```cpp
  int *pi = new int (6);
  double * pd = new double (99.99);
  ```


  **new가 실패하는 경우**

  new는 필요한 메모리 양을 확보할 수 없는 경우가 발생할 수 있다.


  **new: 연산자들, 함수들, 대체 함수들**

  new와 new[] 연산자는 다음 두개의 함수를 호출한다.

  ```cpp
  void * operator new(std::size_t);  // new에서 호출
  void * operator new[](std::size_t);  // new[]에서 호출
  ```
  
  이것들을 대입 함수라고 부르고 대입 함수는 전역 이름 공간의 일부이다.

  C++은 대체 가능한 함수들이 있다.

  사용자가 new, delete에 대한 대체 함수를 마들 수 있다는 의미이다.

  **위치 지정 new 연산자**

  new 연산자는 사용할 위치를 사용자가 지정할 수 있는 위치 지정 new라는 변형이 있다.

  프로그래머는 메모리 관리 절차를 설정하거나 특정 주소를 통해 접근하는 하드웨어를 다루고 특정 메모리 위치에 있는 객체를 생성하는 데 이 기능을 사용할 수 있다.

  위치 지정 new 기능을 사용하려면 new 헤더 파일을 포함시켜야 한다.

  ```cpp
  #include <new>
  struct chaff
  {
    char dross[20];
    int slag;
  };
  char buffer[50];

  int main()
  {
    chaff *p1;
    p1 = new (buffer) chaff;  // 구조체를 buffer에 놓는다
    ...
  }
  ```


## 09.3 이름 공간

C++에서는 변수, 함수, 구조체, 열거체, 클래스, 클래스 멤버와 구조체 멤버를 이름을 통해서 참조할 수 있다.

프로그래밍 프로젝트의 규모가 커짐에 따라, 이름 충돌 가능성이 높아진다.

C++ 표준은 이름 사용 범위를 더 잘 제어할 수 있도록 이름 공간이라는 기능을 제공한다.

* 구식 C++ 이름 공간

  이름 공간 몇 가지 용어
  
  > 첫째 선언 영역, 선언 영역은 선언을 할 수 있는 영역이다.
  
  > 둘째 잠재 사용 범위, 어떤 변수의 잠재 사용 범위는 그 변수를 선언한 지점부터 선언 영역의 끝까지다.
  > 변수는 처음으로 정의한 지점 위에서는 사용할 수 업식에 잠재 사용 범위는 선언 영역보다 좁다.
  

* 새로운 이름 공간 기능

  새로운 종류의 선언 영역을 정의함으로써 이름이 명명된 이름 공간을 만들 수 있는 기능이 C++에 새로 추가되었다.

  그것의 주된 목적은 이름을 선언하는 영역을 따로 제공하는 것이다.

  하나의 이름 공간에 속한 이름은 동일한 이름으로 다른 이름 공간에 선언된 이름과 충돌하지 않는다.

  또 프로그램을 구성하는 여러 부분들이 하나의 이름 공간에 선언된 이름을 사용할 수 있도록 허용하는 방법이 있다.

  EX) 다음과 같은 코드는 namespace라는 새로운 키워드를 사용해 Jack과 Jill이라는 두 개의 이름 공간을 만든다.

  ```cpp
  namespace Jack {
    double pail;    // 변수선언
    void fetch();    // 함수 원형
    int pal;    // 변수 선언
    struct Well  { ... };    // 구조체 선언
  }
  namespace Jill {
    double bucket(double n)  { ... }    // 함수 정의
    double fetch;    // 변수 선언
    int pal    // 변수 선언
    struct Hill  { ... };    // 구조체 선언
  }
  ```

  어떤 하나의 이름 공간에 속한 이름은 다른 이름 공간에 속한 이름과 충돌하지 않는다.

  이름 공간은 항상 열려 있어 기존의 이름 공간에 새로운 이름을 추가할 수 있다.

  어떤 주어진 이름 공간에 속해 있는 이름에 접근할 때 가장 간단한 방법은 사용 범위 결정 연산자 ::을 사용하여 어떤 이름을 주어진 이름 공간으로 제한하는 것이다.

  특별한 이름 공간이 지정되지 않은 이름을 제한되지 않은 이름이라하고 이름 공간이 지정된 이름을 제한된 이름이라 한다.
  
* using 선언과 using 지시자

  사용할 때마다 매번 이름을 제한하는 것은 번거로워, C++는 이름 공간에 속해 있는 이름을 간편하게 사용할 수 있는 using 선언과 using 지시자라는 두 가지 방법을 제공한다.

  using 선언은 하나의 특별한 식별자를 사용할 수 있게 만들고 using 지시자는 그 이름 공간 전체에 접근할 수 있게 만든다.

  using 선언은 제한된 이름 앞에 키워드 using을 붙이는 것이다.

  ```cpp
  using Jill::fetch
  ```

  이 선언 이후에는 Jill::fetch 대신 fetch하는 이름을 사용할 수 있다.

  using 선언은 하나의 이름만 사용할 수 있게 만들지만 using 지시자는 모든 이름을 사용할 수 있게 만든다.

  ```cpp
  #include <iostream>  // 이름들을 std라는 이름공간에 넣는다
  using namespace std;  // 이름들을 전역적으로 사용할 수 있게 만든다
  ```


  **using 지시자 대 using 선언**

  using 지시자와 using 선언을 여러 번 사용하는 것은 같지 않다.

  하나의 using 선언을 사용할 떄, using 선언이 놓이는 위치에 그 이름을 선언하는 것과 같다.

  어떤 특별한 이름이 함수 안에 선언 되어 있으면 using 선언으로 같은 이름을 넣을 수 없다.

  그러나 using 지시자를 사용할 때는 using 선언과 그 이름 공간 자체를 둘 다 포함하는 최소한의 선언 영역에 그 이름들을 선언하는 것과 같다.


  **이름 공간에 대한 보충**

  이름 공간 선언은 중첩 시킬 수 있다. (즉, 선언 안에 또 다른 선언 가능)


  **이름을 명명하지 않은 이름 공간**

  이름 공간의 이름을 생략하면 이름을 명명하지 않은 이름 공간이 만들어진다.

  ```cpp
  namespace
  {
    int ice;
    int bandycoot;
  }
  ```

  이 이름 공간 안에 선언된 이름들의 잠재 사용 범위는 이름을 명명하지 않은 공간을 포함하고 있는 선언 영역의 끝까지이다.


* 이름 공간의 미래

  현 시점에 이름 공간을 이용한 일반적인 프로그래밍 기법에 대해 가이드라인은 다음과 같다.

  > 외부 전역 변수를 사용하지 말고 이름이 명명된  이름 공간에 있는 변수를 사용하라
  
  > 정적 전역 변수를 사용하지 말고 이름이 명명되지 않은 이름 공간에 있는 변수를 사용하라
  
  > 함수 또는 클래스 라이브러리를 개발하고 있다면, 그들을 하나의 이름 공간에 넣어라
  
  > using 지시자는 옛날 코드를 이름 공간 용도로 변환하는 임시 수단으로만 사용하라
  
  > using 지시자를 헤더 파일에 사용하지 마라. 그 이유는 어떤 름을 사용할 수 있게 하는지 알 수 없기 때문이다
  > 또한 헤더 파일들의 순서가 행동에 영향을 미칠 수 있다
  
  > 사용 범위 결정 연산자 또는 using 선언을 사용하여 이름을 선택적으로 들여오라
  
  > using 선언에 대해 전역 범위 대신 선택적으로 지역 번위를 사용하라


  새로운 iostream 헤더 파일은 반드시 std 이름 공간을 사용해야 한다.
